function FlevaR(e = document.body, t = {}, n) { const i = [], o = [], r = function () { const e = t.editor || !1, i = !!t.autosave && t.autosave, o = t.fps ? t.fps : 30, r = t.name ? t.name : "flevar_application"; return { sprite: (() => { const e = document.createElement("canvas"), t = e.getContext("2d"); return e.width = 50, e.height = 50, t.fillStyle = "#D3D3D3", t.fillRect(0, 0, 50, 50), t.fillStyle = "#A9A9A9", t.fillRect(20, 0, 10, 50), t.fillRect(0, 20, 50, 10), e })(), unknowngraphic: (() => { const e = document.createElement("canvas"), t = e.getContext("2d"); return e.width = 50, e.height = 50, t.fillStyle = "#D3D3D3", t.fillRect(0, 0, 50, 50), t.lineWidth = 10, t.strokeStyle = "#A9A9A9", t.strokeRect(0, 0, 50, 50), e })(), useUnknownSound: () => { try { return function (e, t = 44100) { const n = e * t, i = window.AudioContext || window.webkitAudioContext || window.mozAudioContext; i || console.warn("No audio context found on this browser."); const o = (new i).createBuffer(1, n, t); return URL.createObjectURL(function (e, t) { let n, i, o = e.numberOfChannels, r = t * o * 2 + 44, s = new ArrayBuffer(r), c = new DataView(s), a = [], l = 0, u = 0; for (f(1179011410), f(r - 8), f(1163280727), f(544501094), f(16), d(1), d(o), f(e.sampleRate), f(2 * e.sampleRate * o), d(2 * o), d(16), f(1635017060), f(r - u - 4), n = 0; n < e.numberOfChannels; n++)a.push(e.getChannelData(n)); for (; u < r;) { for (n = 0; n < o; n++)i = 0 | (.5 + (i = Math.max(-1, Math.min(1, a[n][l]))) < 0 ? 32768 * i : 32767 * i), c.setInt16(u, i, !0), u += 2; l++ } return new Blob([s], { type: "audio/wav" }); function d(e) { c.setUint16(u, e, !0), u += 2 } function f(e) { c.setUint32(u, e, !0), u += 4 } }(o, n)) }(3, 44100) } catch{ return !1 } }, engine: { version: "FlevaR Version 1.2.0" }, stage: { _width: void 0 !== t._width ? Math.max(400, t._width) : 600, _height: void 0 !== t._height ? Math.max(400, t._height) : 500, _color: "#fff0" }, minStageWidth: 400, minStageHeight: 400, flevar_env: e ? "development" : "production", editor: e, fps: o, applicationName: r, inits: n, graphicPath: "assets", graphicType: "png", soundPath: "assets", soundType: "mp3", autosave: i, Image: Image, Audio: Audio } }(), s = function (e) { const t = e || `${r.applicationName}_${String(Date.now())}`, n = document.createElement("a"); n.download = t, n.href = H.canvas.toDataURL(), n.click() }, c = { DEBUG: t.debug, EDITOR: FlevaR_Editor ? FlevaR_Editor(r.editor, e) : {} }, a = function (e, ...t) { for (const n of t) for (const t of Object.keys(n)) l(e, t, n[t]); Object.defineProperty(e, "type", { get: () => _.typeOf(e), enumerable: !0, configurable: !1 }) }, l = function (e, t, n) { Object.defineProperty(e, t, { get: () => n, enumerable: !0, configurable: !1 }) }, u = { Engine: function () { a(this, ...arguments) }, SharedObject: function () { a(this, ...arguments) }, Mouse: function () { a(this, ...arguments) }, Key: function () { a(this, ...arguments) }, Prefab: function () { a(this, ...arguments) }, TextField: function () { a(this, ...arguments) }, Scene: function () { a(this, ...arguments) }, Script: function () { }, Sprite: function () { a(this, ...arguments) }, Graphic: function () { a(this, ...arguments) }, Sound: function () { a(this, ...arguments) }, SpriteSheet: function () { a(this, ...arguments) }, Painting: function () { a(this, ...arguments) } }; let d = 0; const f = function (e = "symbol") { const t = String(Math.random()).substr(2); return `$${e}_${d++}_${t}` }, h = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, wheelClamp: function (e, t = 0, n = 0) { if (!_.isNumber(e)) return 0; if (!_.isNumber(t)) return e; _.isNumber(n) || (n = 0); const i = Math.min(t, n), o = Math.max(t, n); if (i === o) return i; const r = (e - i) % (o - i); return r > 0 ? r + i : r + o }, lock: function (e, t, n) { return _.isNumber(e) ? _.isNumber(t) ? (_.isNumber(n) || (n = t), e < t ? e = t : e > n && (e = n), e) : e : 0 }, inRange: function (e, t = 0, n = 0) { if (!_.isNumber(e)) return !1; if (!_.isNumber(t)) return !1; if (!_.isNumber(n)) return e === t; const i = Math.min(t, n), o = Math.max(t, n); return e >= i && e <= o }, validateNum: function (e, t = 1, n = 0, i = 1) { return e = "string" == typeof e && /^-?\d+%$/.test(e) ? parseInt(e) / 100 * t : e, this.lock(e, n, i) }, eitherOr: function (e, t, n) { return _.isNumber(e) ? _.isNumber(t) && _.isNumber(n) ? (e !== t && e !== n ? e = t : e === t ? e = n : e === n && (e = t), e) : e : 0 }, cycle: function (e, t, n = 0, i = 1) { return _.isNumber(e) && _.isNumber(t) ? (_.isNumber(n) || (n = 0), _.isNumber(i) || (i = 1), (e = this.lock(e, n, t)) < t ? e += i || 1 : e = n, e) : 0 }, perXSeconds: function (e) { return 1e3 * e }, xPerSecond: function (e) { return 1e3 / e }, rotatePoint: function (e, t, n) { if (0 === n) return this.newPoint(e, t); const i = this.degreesToRadians(n), [o, r] = [e, t], s = o * Math.cos(i) - r * Math.sin(i), c = o * Math.sin(i) + r * Math.cos(i); return this.newPoint(s, c) }, newPoint: function (e = 0, t = 0) { return "object" == typeof e ? { _x: e._x, _y: e._y } : { _x: e, _y: t } }, minMax: function (e, t, ...n) { const i = n.map(t => t[e]); return Math[t](...i) }, degreesToRadians: function (e) { return e * this.DEG2RAD }, radiansToDegrees: function (e) { return e * this.RAD2DEG } }, p = { deepCloneObject: function () { const e = (() => { try { return Reflect.ownKeys } catch{ const e = Object.getOwnPropertyNames, t = Object.getOwnPropertySymbols; return n => e(n).concat(t ? t(n) : []) } })(), { create: t, defineProperty: n, getPrototypeOf: i, getOwnPropertyDescriptor: o } = Object; return function r(s) { if (s instanceof Element || s instanceof HTMLElement || s instanceof Node) return s.cloneNode(!0); const c = t(i(s)); return e(s).forEach(function (e) { const t = o(s, e), i = t.value; if (i) switch (!0) { case i instanceof Date: t.value = new Date(+i); break; case i instanceof RegExp: t.value = new RegExp(i.source, i.flags); break; case i instanceof Object: "function" != typeof i && (t.value = r(i)) }n(c, e, t) }), c } }(), filterObject: function (e = {}, t = "", n = !0) { if (!this.isObject(e)) return; const i = t.split(" "), o = {}; for (const t of Object.keys(e)) !1 === n ? i.includes(t) || (o[t] = e[t]) : i.includes(t) && (o[t] = e[t]); return o }, multiplyObject: function (e = {}, t) { const n = []; for (let i = 0; i < t; i++)n.push(e); return n }, lockObject: function (e = {}) { if (!e instanceof Object) return {}; const t = { ...e }; for (const n of Object.keys(e)) Object.getOwnPropertyDescriptor(e, n).value && (delete e[n], Object.defineProperty(e, n, { get: () => t[n], enumerable: !0, configurable: !1 })); return e }, emptyObject: function (e = {}) { for (const t of Object.keys(e)) delete e[t] }, objectLength: function (e = {}) { return Object.keys(e).length }, clone: function (e) { if (null === e || "object" != typeof e) return e; let t; t = new e.constructor; for (let n of Object.keys(e)) e.hasOwnProperty(n) && (Object.getOwnPropertyDescriptor(e, n).value instanceof Object ? t[n] = this.clone(e[n]) : Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n))); return t } }, _ = { random: function (e, t) { let n, i = Math.random(); if (null !== e && "object" == typeof e) { if (_.isArray(e)) n = 1 === t ? e[this.random(e.length - 1)] : cloneObject(e).sort(function () { return i > .5 ? -1 : 1 }); else if (_.isObject(e)) { const n = Object.keys(e), i = n[n.length * Math.random() << 0]; return 1 === t ? i : e[i] } } else n = "string" == typeof e ? 1 === t ? e.split("")[this.random(e.length - 1)] : e.split("").sort(function () { return i > .5 ? -1 : 1 }).join("") : "number" == typeof e ? "number" == typeof t ? Math.round(i * (t - e)) + e : Math.round(i * e) : i; return n }, isString: function (e) { return "string" == typeof e || e === String }, isNumber: function (e) { return "number" == typeof e || e === Number }, isBigInt: function (e) { return "bigint" == typeof e || e === BigInt }, isBoolean: function (e) { return "boolean" == typeof e || e === Boolean }, isObject: function (e) { try { return e.constructor === Object || e === Object } catch{ return !1 } }, isArray: function (e) { try { return e.constructor === Array || e === Array } catch{ return !1 } }, isSharedObject: function (e) { try { return e.constructor === u.SharedObject || e === u.SharedObject } catch{ return !1 } }, isMouse: function (e) { try { return e.constructor === u.Mouse || e === u.Mouse } catch{ return !1 } }, isKey: function (e) { try { return e.constructor === u.Key || e === u.Key } catch{ return !1 } }, isPrefab: function (e) { try { return e.constructor === u.Prefab || e === u.Prefab } catch{ return !1 } }, isTextField: function (e) { try { return e.constructor === u.TextField || e === u.TextField } catch{ return !1 } }, isFlevaClip: function (e) { return this.isPrefab(e) || this.isTextField(e) }, isScene: function (e) { try { return e.constructor === u.Scene || e === u.Scene } catch{ return !1 } }, isScript: function (e) { try { return e.constructor === u.Script || e === u.Script } catch{ return !1 } }, isSprite: function (e) { try { return e.constructor === u.Sprite || e === u.Sprite } catch{ return !1 } }, isGraphic: function (e) { try { return e.constructor === u.Graphic || e === u.Graphic } catch{ return !1 } }, isSound: function (e) { try { return e.constructor === u.Sound || e === u.Sound } catch{ return !1 } }, isPainting: function (e) { try { return e.constructor === u.Painting || e === u.Painting } catch{ return !1 } }, isSpriteSheet: function (e) { try { return e.constructor === u.SpriteSheet || e === u.SpriteSheet } catch{ return !1 } }, isEngine: function (e) { try { return e.constructor === u.Engine || e === u.Engine } catch{ return !1 } }, isEngineNative: function (e) { return !["string", "number", "bigint", "boolean", "object", "array", "function", "undefined", "null", "unknown"].includes(this.typeOf(e)) }, isFunction: function (e) { return "function" == typeof e || e === Function }, isScriptOrFunction: function (e) { return this.isScript(e) || this.isFunction(e) }, isUndefined: function (e) { return void 0 === e }, isNull: function (e) { return !this.isUndefined(e) && !this.isObject(e) }, isDefined: function (e) { return !this.isUndefined(e) }, typeOf: function (e) { const t = [{ func: this.isString, type: "string" }, { func: this.isNumber, type: "number" }, { func: this.isBigInt, type: "bigint" }, { func: this.isBoolean, type: "boolean" }, { func: this.isObject, type: "object" }, { func: this.isSharedObject, type: "sharedobject" }, { func: this.isPrefab, type: "prefab" }, { func: this.isTextField, type: "textfield" }, { func: this.isScene, type: "scene" }, { func: this.isScript, type: "script" }, { func: this.isSprite, type: "sprite" }, { func: this.isGraphic, type: "graphic" }, { func: this.isSound, type: "sound" }, { func: this.isPainting, type: "painting" }, { func: this.isSpriteSheet, type: "spritesheet" }, { func: this.isMouse, type: "mouse" }, { func: this.isKey, type: "key" }, { func: this.isEngine, type: "engine" }, { func: this.isArray, type: "array" }, { func: this.isFunction, type: "function" }, { func: this.isUndefined, type: "undefined" }, { func: this.isNull, type: "null" }]; for (const { func: n, type: i } of Object.values(t)) if (n.call(this, e)) return i; return "unknown" } }, g = {}; let m = t.hitAccuracy || 10; const y = { list: [], swapDepths: (e, t) => { y.list.find(t => t.stackName === e).depth = t, y.sortList() }, sortList: () => { y.list.sort((e, t) => e.depth - t.depth) } }, C = { _x: 0, _y: 0, movX: 0, movY: 0 }, w = { isHidden: !1 }, S = {}, b = {}, x = function (e) { const t = H.canvas.getBoundingClientRect(), n = H.canvas.width / t.width, i = H.canvas.height / t.height; C.movX = parseInt((e.clientX - t.left) * n), C.movY = parseInt((e.clientY - t.top) * i), C._x = C.movX, C._y = C.movY }, v = function (e) { x(e), 0 === e.button ? (void 0 === w._left && (w._left = !0), void 0 === S._left && (S._left = !0)) : 1 === e.button ? (void 0 === w._middle && (w._middle = !0), void 0 === S._middle && (S._middle = !0)) : 2 === e.button && (void 0 === w._right && (w._right = !0), void 0 === S._right && (S._right = !0)) }, P = function (e) { 0 === e.button ? (w._left && delete w._left, void 0 !== S._left && (delete S._left, be && void 0 === b._left && (b._left = !0))) : 1 === e.button ? (w._middle && delete w._middle, void 0 !== S._middle && (delete S._middle, be && void 0 === b._middle && (b._middle = !0))) : 2 === e.button && (w._right && delete w._right, void 0 !== S._right && (delete S._right, be && void 0 === b._right && (b._right = !0))) }, O = function (e) { be && (void 0 !== w._left && delete w._left, void 0 !== S._left && delete S._left, void 0 !== b._left && delete b._left, void 0 !== w._middle && delete w._middle, void 0 !== S._middle && delete S._middle, void 0 !== b._middle && delete b._middle, void 0 !== w._right && delete w._right, void 0 !== S._right && delete S._right, void 0 !== b._right && delete b._right) }, L = function () { for (const e of Object.keys(S)) S[e] && (S[e] = !1); for (const e of Object.keys(b)) delete b[e] }, k = function (e) { ke.hidden ? H.div.style.cursor = "none" : H.div.style.cursor = e }, A = {}, F = {}, T = {}, M = function (e) { e.preventDefault(), void 0 === A["code_" + e.keyCode] && (A["code_" + e.keyCode] = !0), void 0 === A["name_" + e.key.toLowerCase()] && (A["name_" + e.key.toLowerCase()] = !0), void 0 === F["code_" + e.keyCode] && (F["code_" + e.keyCode] = !0), void 0 === F["name_" + e.key.toLowerCase()] && (F["name_" + e.key.toLowerCase()] = !0) }, E = function (e) { A["code_" + e.keyCode] && delete A["code_" + e.keyCode], A["name_" + e.key.toLowerCase()] && delete A["name_" + e.key.toLowerCase()], void 0 !== F["code_" + e.keyCode] && (delete F["code_" + e.keyCode], be && void 0 === T["code_" + e.keyCode] && (T["code_" + e.keyCode] = !0)), void 0 !== F["name_" + e.key.toLowerCase()] && (delete F["name_" + e.key.toLowerCase()], be && void 0 === T["name_" + e.key.toLowerCase()] && (T["name_" + e.key.toLowerCase()] = !0)) }, j = function (e) { for (const e of Object.keys(F)) F[e] && (F[e] = !1); for (const e of Object.keys(T)) delete T[e]; if (e) for (const e of Object.keys(A)) delete A[e] }, N = () => { _.isScriptOrFunction(null) && $.getScriptOrFunction(null)(Ve) }, H = function () { null == e && (e = document.body); const [t, n] = [r.stage._width, r.stage._height], i = document.createElement("div"); i.setAttribute("style", `border-style: solid; border-width: 2px; width: ${t}px; height: ${n}px; position: relative;`), i.style.overflow = "hidden", i.style.outline = "none", i.style.border = "none", i.tabIndex = "0"; const o = document.createElement("canvas"); o.setAttribute("style", "position: absolute;"), o.width = t, o.height = n; const s = o.getContext("2d"); return s.imageSmoothingEnabled = !1, Object.defineProperties(s, { width: { get: function () { return t }, enumerable: !0, configurable: !1 }, height: { get: function () { return n }, enumerable: !0, configurable: !1 } }), i.appendChild(o), e.appendChild(i), { ctx: s, canvas: o, div: i } }(), D = { flevaclips: {}, scripts: {}, scenes: {}, sprites: {}, graphics: {}, spritesheets: {}, paintings: {}, sounds: {}, hasFlevaClip: function (e) { return !!this.flevaclips[e] }, hasScript: function (e) { return !!this.scripts[e] }, hasScene: function (e) { return !!this.scenes[e] }, hasSprite: function (e) { return !!this.sprites[e] }, hasGraphic: function (e) { return !!this.graphics[e] }, hasSound: function (e) { return !!this.sounds[e] }, hasSpriteSheet: function (e) { return !!this.spritesheets[e] }, hasPainting: function (e) { return !!this.paintings[e] } }, B = { scripts: [], scene: "" }, I = { showingPage: !0 }, V = function () { }, $ = { trace: console.log.bind(window.console), flatted: (() => { "use strict"; const { parse: e, stringify: t } = JSON, { keys: n } = Object, i = String, o = "string", r = "object", s = (e, t) => t, c = e => e instanceof i ? i(e) : e, a = (e, t) => typeof t === o ? new i(t) : t, l = (e, t, o, s) => n(o).reduce((n, o) => { const c = n[o]; if (c instanceof i) { const i = e[c]; typeof i !== r || t.has(i) ? n[o] = s.call(n, o, i) : (t.add(i), n[o] = s.call(n, o, l(e, t, i, s))) } else n[o] = s.call(n, o, c); return n }, o), u = (e, t, n) => { const o = i(t.push(n) - 1); return e.set(n, o), o }; return { parse: (t, n) => { const i = e(t, a).map(c), o = i[0], u = n || s, d = typeof o === r && o ? l(i, new Set, o, u) : o; return u.call({ "": d }, "", d) }, stringify: (e, n, i) => { const c = n && typeof n === r ? (e, t) => "" === e || -1 < n.indexOf(e) ? t : void 0 : n || s, a = new Map, l = [], d = []; let f = +u(a, l, c.call({ "": e }, "", e)), h = !f; for (; f < l.length;)h = !0, d[f] = t(l[f++], p, i); return "[" + d.join(",") + "]"; function p(e, t) { if (h) return h = !h, t; const n = c.call(this, e, t); switch (typeof n) { case r: if (null === n) return n; case o: return a.get(n) || u(a, l, n) }return n } } } })(), renderFlevaClip: ({ _bounds: e, _clip: t, ...n }, i, o = []) => { const { ctx: r } = H, { _x: s = 0, _y: a = 0, _width: l = 50, _height: u = 50, _alpha: d = 1, _visible: f, _rotation: p, _anchorX: g, _anchorY: m } = n; if ($.boxHitTest({ _x: 0, _y: 0, _width: r.width, _height: r.height }, e)) { if (f) { r.save(), _.isDefined(d) && 1 !== d && (r.globalAlpha = d), r.translate(s, a), p && r.rotate(h.degreesToRadians(p)), r.translate(-(s + g), -(a + m)); let e = s, c = a; l < 0 && (r.scale(-1, 1), e *= -1, n._x = e, n._width *= -1), u < 0 && (r.scale(1, -1), c *= -1, n._y = c, n._height *= -1), t && (r.beginPath(), r.rect(n._x, n._y, n._width, n._height), r.closePath(), r.clip()), i(n, ...o), r.restore() } c.EDITOR.canRenderBounds && c.EDITOR.renderBounds(r, { _x: s, _y: a, _rotation: p, _bounds: e }) } }, renderScene: (e, t = []) => { const { ctx: n } = H, i = { _x: 0, _y: 0, _width: n.width, _height: n.height }; n.save(), n.beginPath(), n.rect(i._x, i._y, i._width, i._height), n.closePath(), n.clip(), e(i, ...t), n.restore() }, drawSprite: ({ _x: e = 0, _y: t = 0, _width: n = 50, _height: i = 50 } = {}, o) => { R.checkSpriteNotExist(o), H.ctx.drawImage(D.sprites[o].src, e, t, n, i) }, drawGraphic: ({ _x: e = 0, _y: t = 0, _width: n = 50, _height: i = 50 } = {}, o) => { R.checkGraphicNotExist(o), H.ctx.drawImage(D.graphics[o].src, e, t, n, i) }, drawPainting: ({ _x: e = 0, _y: t = 0, _width: n = 50, _height: i = 50 } = {}, o) => { if (_.isString(o)) { R.checkPaintingNotExist(o); let { src: r } = fe(o); (r = r.bind(H.ctx))(H.ctx, e, t, n, i) } else _.isScriptOrFunction(o) && $.getScriptOrFunction(o)(H.ctx, e, t, n, i) }, getPixelMap: e => { let t; try { t = D.sprites[e].pixelMap } catch{ } return t }, getRotatedMappedPoint: function (e, t) { const n = { _x: e._x - t._x, _y: e._y - t._y }, i = 0 === t._rotation ? n : h.rotatePoint(n._x, n._y, -t._rotation), o = i._x + t._x, r = i._y + t._y; return { _x: o + t._anchorX, _y: r + t._anchorY } }, boxHitTest: function (e, t) { const n = e._width >= 0 ? e._x : e._x + e._width, i = e._height >= 0 ? e._y : e._y + e._height, o = Math.abs(e._width), r = Math.abs(e._height), s = t._width >= 0 ? t._x : t._x + t._width, c = t._height >= 0 ? t._y : t._y + t._height, a = Math.abs(t._width), l = Math.abs(t._height); return !(i + r < c || i > c + l || n + o < s || n > s + a) }, boxHitTestPoint: function (e, t) { const n = e._width >= 0 ? e._x : e._x + e._width, i = e._height >= 0 ? e._y : e._y + e._height, o = Math.abs(e._width); return !(i + Math.abs(e._height) < t._y || i > t._y || n + o < t._x || n > t._x) }, pixelHitTest: function (e, t) { return !!e.pixelMap }, pixelHitTestPoint: function (e, t) { if (!e.pixelMap) return !1; const n = t._x - e._x, i = t._y - e._y, o = n * (e.pixelMap._width / e._width), r = i * (e.pixelMap._height / e._height), s = Math.floor(o / m) * m, c = Math.floor(r / m) * m, a = e.pixelMap.data[s + "_" + c]; return !!a && a > 55 }, getScriptOrFunction: function (e) { let t; return _.isScript(e) && e.idName ? t = ae(e.idName) : _.isScriptOrFunction(e) && (t = e), t } }, R = { checkCanUseName: function (e, t = "symbol") { if (!("string" == typeof e && "" !== e.trim() && null === e.match(/^[^a-zA-Z_]|[^\w]/g))) throw `Invalid ${t} name declaration: "${e}".` }, checkFlevaClipExist: function (e, t) { if (this.checkCanUseName(e, "flevaclip"), t) { if (t[e]) throw `FlevaClip already exists: "${e}".` } else if (D.hasFlevaClip(e)) throw `FlevaClip already exists: "${e}".` }, checkFlevaClipNotExist: function (e, t) { if (t) { if (!t[e]) throw `FlevaClip does not exist: "${e}".` } else if (!D.hasFlevaClip(e)) throw `FlevaClip does not exist: "${e}".` }, checkScriptExist: function (e, t) { if (this.checkCanUseName(e, "script"), t) { if (t[e]) throw `Script already exists: "${e}".` } else if (D.hasScript(e)) throw `Script already exists: "${e}".` }, checkScriptNotExist: function (e, t) { if (t) { if (!t[e]) throw `Script does not exist: "${e}".` } else if (!D.hasScript(e)) throw `Script does not exist: "${e}".` }, checkSceneExist: function (e, t) { if (this.checkCanUseName(e, "scene"), t) { if (t[e]) throw `Scene already exists: "${e}".` } else if (D.hasScene(e)) throw `Scene already exists: "${e}".` }, checkSceneNotExist: function (e, t) { if (t) { if (!t[e]) throw `Scene does not exist: "${e}".` } else if (!D.hasScene(e)) throw `Scene does not exist: "${e}".` }, checkSpriteExist: function (e, t) { if (this.checkCanUseName(e, "sprite"), t) { if (t[e]) throw `Sprite already exists: "${e}".` } else if (D.hasSprite(e)) throw `Sprite already exists: "${e}".` }, checkSpriteNotExist: function (e, t) { if (t) { if (!t[e]) throw `Sprite does not exist: "${e}".` } else if (!D.hasSprite(e)) throw `Sprite does not exist: "${e}".` }, checkGraphicExist: function (e, t) { if (this.checkCanUseName(e, "graphic"), t) { if (t[e]) throw `Graphic already exists: "${e}".` } else if (D.hasGraphic(e)) throw `Graphic already exists: "${e}".` }, checkGraphicNotExist: function (e, t) { if (t) { if (!t[e]) throw `Graphic does not exist: "${e}".` } else if (!D.hasGraphic(e)) throw `Graphic does not exist: "${e}".` }, checkSoundExist: function (e, t) { if (this.checkCanUseName(e, "sound"), t) { if (t[e]) throw `Sound already exists: "${e}".` } else if (D.hasSound(e)) throw `Sound already exists: "${e}".` }, checkSoundNotExist: function (e, t) { if (t) { if (!t[e]) throw `Sound does not exist: "${e}".` } else if (!D.hasSound(e)) throw `Sound does not exist: "${e}".` }, checkSpriteSheetExist: function (e, t) { if (this.checkCanUseName(e, "spritesheet"), t) { if (t[e]) throw `SpriteSheet already exists: "${e}".` } else if (D.hasSpriteSheet(e)) throw `SpriteSheet already exists: "${e}".` }, checkSpriteSheetNotExist: function (e, t) { if (t) { if (!t[e]) throw `SpriteSheet does not exist: "${e}".` } else if (!D.hasSpriteSheet(e)) throw `SpriteSheet does not exist: "${e}".` }, checkPaintingExist: function (e, t) { if (this.checkCanUseName(e, "painting"), t) { if (t[e]) throw `Painting already exists: "${e}".` } else if (D.hasPainting(e)) throw `Painting already exists: "${e}".` }, checkPaintingNotExist: function (e, t) { if (t) { if (!t[e]) throw `Painting does not exist: "${e}".` } else if (!D.hasPainting(e)) throw `Painting does not exist: "${e}".` } }, W = function () { let e, t = (() => { const e = {}; self.onmessage = function ({ data: t }) { const { code: n, id: i, interval: o } = t; "step" === n ? e[i] = setTimeout(() => { self.postMessage({ message: "step", id: i }) }, o) : "clear" === n && (clearTimeout(e[i]), delete e[i]) } }).toString(); t = t.substring(t.indexOf("{") + 1, t.lastIndexOf("}")); try { e = new Blob([t], { type: "application/javascript" }) } catch (n) { const i = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder); i.append(t), e = i.getBlob("application/javascript") } return new Worker(URL.createObjectURL(e)) }(), Y = class { constructor(e, t, n = 1e3, i, o = !1, r = 0) { this.id = e, this.expected, this.timeout, this.interval = n, this.workFunc = t, this.errorFunc = i, this.skipOlds = o, this.maxTimes = r, this.isRunning = !1, this.timesExecuted = 0, this.step = this.step.bind(this) } start(e) { if (this.isRunning) return; this.isRunning = !0; const t = e ? 0 : this.interval; this.expected = Date.now() + t, W.postMessage({ code: "step", id: this.id, interval: t }) } stop() { this.isRunning && (this.isRunning = !1, W.postMessage({ code: "clear", id: this.id })) } async step() { let e = Date.now() - this.expected; if (await this.workFunc(), e > this.interval ? this.errorFunc ? this.errorFunc() : this.skipOlds ? this.expected += e : this.expected += this.interval : this.expected += this.interval, this.maxTimes > 0 && (this.timesExecuted++, this.timesExecuted >= this.maxTimes)) return this.stop(); W.postMessage({ code: "step", id: this.id, interval: Math.max(0, this.interval - e) }) } }, X = function () { const e = {}; let t = 0; const n = () => { const e = String(Math.random()).substr(2); return `$loop_${t++}_${e}` }; W.onmessage = function ({ data: t }) { e[t.id] && e[t.id].exec.step() }; const i = { addLoop: (t, i, { _startNow: o = !1, _skipOlds: r = !1, _iterations: s = 0 } = {}) => { const c = n(); return e[c] = { type: "loop", exec: new Y(c, t, i, null, r, s) }, e[c].exec.start(o), c }, pauseLoop: t => { e[t] && "loop" !== !e[t].type && e[t].exec.stop() }, playLoop: (t, n) => { e[t] && "loop" !== !e[t].type && e[t].exec.start(n) }, removeLoop: t => { e[t] && "loop" !== !e[t].type && (e[t].exec.stop(), delete e[t]) }, addTimeout: (t, i) => { const o = n(); return e[o] = { type: "timeout", exec: new Y(o, t, i, null, !1, 1) }, e[o].exec.start(!1), o }, removeTimeout: t => { e[t] && "timeout" !== !e[t].type && (e[t].exec.stop(), delete e[t]) } }; return Object.defineProperties(i, { loops: { get: function () { return Object.keys(e).length }, enumerable: !1, configurable: !1 } }), i }(), G = function (e) { const t = e = $.getScriptOrFunction(e); return t.constructor = u.Script, t }, U = function ({ _x: e = 0, _y: t = 0, _width: n = 100, _height: i = 20, _padding: o = 0, _fontSize: r = 20, _lineHeight: s = 0, _fontFamily: c = "sansSerif", _textAlign: a = "left", _text: l, _multiline: u = !0, _wordWrap: d = !0, _type: f = "dynamic", _backgroundColor: h = 0, _borderColor: p = 0, _fontColor: g = "black", _alpha: m = 1, _visible: y = !0, _rotation: C = 0, _anchorX: w = 0, _anchorY: S = 0 } = {}) { const { div: b, ctx: x } = H, v = {}; v.x = parseInt(e), v.y = parseInt(t), v.width = parseInt(n), v.height = parseInt(i), v.padding = parseInt(o), v.fontSize = parseInt(r), v.fontColor = g, v.lineHeight = parseInt(s), v.type = ["dynamic", "input", "password"].includes(f) ? f : "dynamic", v.fontFamily = "password" === v.type ? "monospace" : c, v.backgroundColor = h || ("dynamic" === v.type ? "none" : "white"), v.borderColor = p || ("dynamic" === v.type ? "none" : "green"), v.textAlign = a, v.initialText = l, v.multiline = "password" !== v.type && u, v.wordWrap = !1 !== v.multiline && (![!0, !1].includes(d) || d); const P = { _alpha: 1, _visible: !0, _rotation: 0, _anchorX: 0, _anchorY: 0 }; if (arguments[0]) { const e = arguments[0]; if (!_.isObject(e)) return; for (const t of Object.keys(e)) _.isDefined(P[t]) && (P[t] = e[t]) } const O = {}; O.__x = v.x, O.__y = v.y, O.__width = v.width, O.__height = v.height, O.__font = v.fontFamily, O.__size = v.fontSize, O.__type = v.type, O.__backgroundColor = v.backgroundColor, O.__borderColor = v.borderColor, O.__fontColor = v.fontColor, O.__lineHeight = v.lineHeight || v.fontSize, O.__padding = v.padding, O.__wrap = v.wordWrap, O.__textAlign = ["left", "center", "right"].includes(v.textAlign) ? v.textAlign : "left", O.__focused = !1, O.__hovered = !1; const L = { newLineCode: "\n", contents: [], lines: [""], linesAligned: [], lineBreaks: [], __cursorPosition: 0, currentLine: 0, currentLineCursorPosition: 0, currentLineCursorPixels: 0, intendedCursorPixels: 0, cantGoThroughVals: ["\n", ".", "+", "-", '"', "'", "/", "?", ",", ";", ":"], goThroughVals: [" ", "(", ")"], selectorCursorPosition1: void 0, selectorCursorPosition2: void 0, minSelectionPosition: void 0, maxSelectionPosition: void 0, canSelectWithMouse: !1 }, A = { __contentX: 0, __contentY: 0, contentWidth: 0, contentHeight: 0 }; function F(e) { return "password" === O.__type ? x.measureText("*").width * e.length : x.measureText(e).width } v.keys = {}, v.mouse = { isDown: !1 }, v.initialize = (() => { Object.defineProperties(D, { _fontSize: { get: () => O.__size, set(e) { e = Math.max(8, Math.min(parseInt(e), 80)); const t = O.__size, n = O.__lineHeight; O.__size = e, O.__lineHeight = n / t * e, L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _padding: { get: () => O.__padding, set(e) { O.__padding = parseInt(e), L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _width: { get: () => O.__width, set(e) { e = Math.max(2, parseInt(e)), O.__width = e, L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _height: { get: () => O.__height, set(e) { e = Math.max(2, parseInt(e)), O.__height = e, L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _x: { get: () => O.__x, set(e) { O.__x = e }, enumerable: !0 }, _y: { get: () => O.__y, set(e) { O.__y = e }, enumerable: !0 }, _text: { get: () => E.getText(), set(e) { E.setText(e) }, enumerable: !0 }, _textAlign: { get: () => O.__textAlign, set(e) { e = ["right", "center", "left"].includes(e) ? e : "left", O.__textAlign = e, L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _backgroundColor: { get: () => O.__backgroundColor, set(e) { O.__backgroundColor = e }, enumerable: !0 }, _borderColor: { get: () => O.__borderColor, set(e) { O.__borderColor = e }, enumerable: !0 }, _fontColor: { get: () => O.__fontColor, set(e) { O.__fontColor = e }, enumerable: !0 } }), "dynamic" !== O.__type && Object.defineProperties(D, { _focused: { get: () => O.__focused, set(e) { if (![!0, !1].includes(e)) return; const t = O.__focused === e; O.__focused = e, t || (e ? (ge(), _e(T.unselect)) : ge()) }, enumerable: !0 } }), ["input", "dynamic"].includes(O.__type) && Object.defineProperties(D, { _wordWrap: { get: () => O.__wrap, set(e) { O.__wrap = !1 !== v.multiline && (![!0, !1].includes(e) || e), L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _fontFamily: { get: () => O.__font, set(e) { O.__font = e.replace(/-([A-Za-z])/g, (e, t) => t.toUpperCase()), "password" === O.__type && (O.__font = "monospace"), L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 }, _lineHeight: { get: () => O.__lineHeight, set(e) { O.__lineHeight = parseInt(e), L.getLinesFromContent(), L.getContentPositions() }, enumerable: !0 } }), Object.defineProperties(A, { fontFamily: { get: () => `${O.__size}px ${O.__font}` }, innerWidth: { get: () => O.__width - 2 * O.__padding - 2 || 1 }, innerHeight: { get: () => O.__height - 2 * O.__padding - 2 || 1 }, innerX: { get: () => O.__x + O.__padding + 1 }, innerY: { get: () => O.__y + O.__padding + 1 }, contentX: { get: () => A.__contentX, set(e) { A.__contentX = e > 0 ? 0 : e } }, contentY: { get: () => A.__contentY, set(e) { A.__contentY = e > 0 ? 0 : e } } }), Object.defineProperties(L, { cursorPosition: { get: () => L.__cursorPosition, set: e => { L.__cursorPosition = e, L.getCurrentLineAndCursorPosition() } }, pageY: { get: () => O.__y + b.offsetTop }, pageX: { get: () => O.__x + b.offsetLeft }, pageCursorY: { get: () => L.currentLine * O.__lineHeight + L.pageY + A.contentY }, pageCursorX: { get: () => { x.save(), x.font = A.fontFamily; const e = F(L.lines[L.currentLine].substr(0, L.currentLineCursorPosition)); return x.restore(), e + L.pageX + A.contentX } } }); const e = { mouseUp: e => { T.checkMouseAction(e, v.keys.shft, "up") }, mouseMove: e => { T.checkMouseAction(e, v.keys.shft, "move") }, keyDown: e => { T.checkKeyDown(e) }, keyUp: e => { T.checkKeyUp(e) } }; "dynamic" !== O.__type && (N.__load = (() => { b.addEventListener("mouseup", e.mouseUp), b.addEventListener("mousemove", e.mouseMove), b.addEventListener("keydown", e.keyDown), b.addEventListener("keyup", e.keyUp) }), N.__unload = (() => { b.removeEventListener("mouseup", e.mouseUp), b.removeEventListener("mousemove", e.mouseMove), b.removeEventListener("keydown", e.keyDown), b.removeEventListener("keyup", e.keyUp), L.resetSelectedArea() }), N.___setSelection = ((e, t) => (T.checkMouseAction({ offsetX: e, offsetY: t }, v.keys.shft, "down"), T.unselect))), v.initialText && M.appendText(v.initialText, !1), L.getLinesFromContent() }), L.getCursorPosition = ((e, t) => { if ((t = Math.floor(t / O.__lineHeight)) > L.lines.length - 1) return L.cursorPosition = L.contents.length; if (t < 0) return L.cursorPosition = 0; const n = L.lines[t].length || 0, i = L.linesAligned[t], o = L.getCursorPositionByLineWidth(L.lines[t], e - i, n); let r = 0; for (let e = 0; e < t; e++)r += L.lines[e].length, L.lineBreaks.includes(e) && r++; L.cursorPosition = r + o }), L.getCursorPositionByLineWidth = ((e = "", t = 0, n = 0) => { let i = "", o = 0; x.save(), x.font = A.fontFamily; for (const r of Object.keys(e)) { const s = parseInt(r); if (i += e[s], (o = Math.round(F(i))) > t) { const e = Math.round(F(i.substr(0, s))); n = Math.abs(t - e) < Math.abs(t - o) ? s : s + 1; break } } return x.restore(), n }), L.getCurrentLineAndCursorPosition = (() => { const e = L.lines; let t = 0, n = L.cursorPosition, i = 0, o = 0; for (let i = 0; i < e.length; i++) { const r = e[i].length; if (!(n - r > 0 && t + 1 < e.length)) break; n -= r, o += r, L.lineBreaks.includes(i) && (n--, o++), t++ } i = L.cursorPosition - o, L.currentLine = t, L.currentLineCursorPosition = i, x.save(), x.font = A.fontFamily; const r = L.lines[L.currentLine].substr(0, L.currentLineCursorPosition); L.currentLineCursorPixels = F(r) + L.linesAligned[L.currentLine], x.restore() }), L.getWidthAtIndex = ((e, t) => { x.save(), x.font = A.fontFamily; const n = F(e.substr(0, t)); return x.restore(), n }), L.getWordAtWidth = ((e = "", t = 0) => { if (0 === t) return { containedWord: "", excessLength: e.length }; let n = "", i = 0, o = 0; x.save(), x.font = A.fontFamily; for (const r of Object.keys(e)) { const s = parseInt(r); if (n += e[s], i = Math.round(F(n)), 1 === n.length && i >= t) { o = s + 1; break } if (i >= t) { o = s; break } } const r = e.substr(0, o), s = e.substr(o).length; return x.restore(), { containedWord: r, excessLength: s } }), L.escapeContent = (() => { !1 === v.multiline && (L.contents = L.contents.filter(e => e !== L.newLineCode)) }), L.getLinesFromContent = (() => { const e = L.newLineCode; x.save(), x.font = A.fontFamily, L.escapeContent(); const t = L.contents, n = [], i = A.innerWidth; let o = 0, r = !0, s = "", c = "", a = 0; const l = [], u = O.__wrap; for (; o < t.length;)if (" " !== t[o] && t[o] !== e && (s += t[o].substring(0, 1), o++), o === t.length) { if ("" !== s) if (!1 === u) r ? (c = s, r = !1, s = "") : (c += s, s = ""); else if (r) if (F(s) < i) c = s, r = !1, s = ""; else { const e = L.getWordAtWidth(s, i); n[a] = e.containedWord, a++, c = "", o -= e.excessLength, s = "", r = !0 } else F(c + s) >= i ? (n[a] = c, a++, c = "", o -= s.length, s = "", r = !0) : (c += s, s = "") } else if (" " === t[o]) if ("" !== s) if (!1 === u) r ? (c = s + " ", r = !1, s = "", o++) : (c += s + " ", s = "", o++); else if (r) if (F(s) < i) c = s + " ", r = !1, s = "", o++; else { const e = L.getWordAtWidth(s, i); n[a] = e.containedWord, a++, c = "", o -= e.excessLength, s = "", r = !0 } else F(c + s) >= i ? (n[a] = c, a++, c = "", o -= s.length, s = "", r = !0) : (c += s + " ", s = "", o++); else c += " ", o++, r = !1; else if (t[o] === e) if ("" !== s) if (!1 === u) r ? (c = s, r = !1, s = "", l.push(a), n[a] = c, a++, r = !0, c = "", o++) : (c += s, s = "", l.push(a), n[a] = c, a++, r = !0, c = "", o++); else if (r) if (F(s) < i) c = s, r = !1, s = "", l.push(a), n[a] = c, a++, r = !0, c = "", o++; else { const e = L.getWordAtWidth(s, i); n[a] = e.containedWord, a++, c = "", o -= e.excessLength, s = "", r = !0 } else F(c + s) >= i ? (n[a] = c, a++, c = "", o -= s.length, s = "", r = !0) : (c += s, s = "", l.push(a), n[a] = c, a++, r = !0, c = "", o++); else l.push(a), n[a] = c, a++, r = !0, c = "", o++; n[a] = c, c = "", x.restore(), L.lines = n, L.lineBreaks = l, L.getAlignments(), L.getContentDimensions(), L.getCurrentLineAndCursorPosition() }), L.getAlignments = (() => { x.save(), x.font = A.fontFamily; const e = O.__textAlign; for (let t = 0; t < L.lines.length; t++)if ("right" === e) { const e = F(L.lines[t]); L.linesAligned[t] = Math.max(0, A.innerWidth - e) } else if ("center" === e) { const e = F(L.lines[t]); L.linesAligned[t] = Math.max(0, A.innerWidth / 2 - e / 2) } else L.linesAligned[t] = 0; x.restore() }), L.getContentDimensions = (() => { x.save(), x.font = A.fontFamily; let e = 0; const t = (L.lines.length - 1) * O.__lineHeight + O.__size; for (let t = 0; t < L.lines.length; t++) { const n = F(L.lines[t]); n > e && (e = n) } A.contentWidth = e, A.contentHeight = t, x.restore() }), L.getContentPositions = (() => { x.save(), x.font = A.fontFamily; const { contentY: e, contentHeight: t, innerHeight: n } = A, i = L.currentLine * O.__lineHeight + e, o = t + e; let r = 0; O.__size > n ? r = i : o < n && e < 0 ? r = o - n : n >= t && 0 !== e ? r = e : i < 0 ? r = i : i + O.__size > n && (r = i + O.__size - n), 0 !== r && (A.contentY -= r), window.pageYOffset > L.pageCursorY ? window.scroll(window.pageXOffset, L.pageCursorY) : window.pageYOffset + window.innerHeight < L.pageCursorY + O.__lineHeight && window.scroll(window.pageXOffset, L.pageCursorY - window.innerHeight + O.__lineHeight), window.pageXOffset > L.pageCursorX ? window.scroll(L.pageCursorX, window.pageYOffset) : window.pageXOffset + window.innerWidth < L.pageCursorX + O.__lineHeight && window.scroll(L.pageCursorX - window.innerWidth + O.__lineHeight, window.pageYOffset); let s = 0; const { contentX: c, contentWidth: a, innerWidth: l } = A; if (!1 === O.__wrap) { const e = F(L.lines[L.currentLine].substr(0, L.currentLineCursorPosition)) + c, t = a + c; t < l && c < 0 ? s = t - l : l >= a && 0 !== c ? s = c : e < 0 ? s = e : e > l && (s = e - l) } else 0 !== c && (s = c); 0 !== s && (A.contentX -= s), x.restore() }), L.getNextCursorPosition = ((e, t = 0) => { let n = !1; const { cantGoThroughVals: i, goThroughVals: o } = L; if (i.includes(e[t])) return t + 1; for (let r = t; r < e.length; r++) { if (o.includes(e[r])) { if (o.includes(e[r]) && n) return r } else n = !0; if (i.includes(e[r]) && r !== t) return r } return e.length }), L.getPrevCursorPosition = ((e, t = 0) => { let n = !1; const { cantGoThroughVals: i, goThroughVals: o } = L; if (i.includes(e[t - 1])) return t - 1; for (let r = t; r >= 0; r--) { if (o.includes(e[r - 1])) { if (o.includes(e[r - 1]) && n) return r } else n = !0; if (i.includes(e[r - 1]) && r !== t) return r } return 0 }), L.getSelectedArea = (() => { const { selectorCursorPosition1: e, selectorCursorPosition2: t } = L; if (void 0 === e || void 0 === t) return L.minSelectionPosition = void 0, L.maxSelectionPosition = void 0, null; L.minSelectionPosition = Math.min(e, t), L.maxSelectionPosition = Math.max(e, t) }), L.getSelectedText = (() => L.contents.join("").substring(L.minSelectionPosition, L.maxSelectionPosition)), L.hasSelectedArea = (() => void 0 !== L.minSelectionPosition && void 0 !== L.maxSelectionPosition), L.resetSelectedArea = (() => { L.selectorCursorPosition1 = void 0, L.selectorCursorPosition2 = void 0, L.minSelectionPosition = void 0, L.maxSelectionPosition = void 0 }); const T = {}; if ("dynamic" !== O.__type) { !function () { function e(e) { const [t, n] = [window.pageXOffset, window.pageYOffset], i = document.createElement("textarea"); i.value = e, i.setAttribute("readonly", ""), i.style = { position: "absolute", left: "-9999px" }, document.body.appendChild(i), i.select(), document.execCommand("copy"), document.body.removeChild(i), b.focus(), window.scroll(t, n) } function t(e) { Le.clipboard = e } T.unselect = (() => { O.__focused = !1, L.resetSelectedArea() }), T.checkMouseAction = (({ offsetX: e, offsetY: t }, n, i) => { "down" !== i || n || L.resetSelectedArea(), "down" === i && (O.__focused = O.__hovered); const { _x: o, _y: r } = $.getRotatedMappedPoint({ _x: e, _y: t }, D); "move" === i && (O.__hovered = o >= O.__x && o <= O.__x + O.__width && r >= O.__y && r <= O.__y + O.__height), O.__focused && ("down" === i && (L.canSelectWithMouse = !0, v.mouse.isDown = !0), v.mouse.isDown && L.canSelectWithMouse && (L.getCursorPosition(o - A.innerX - A.contentX, r - A.innerY - A.contentY), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions()), "down" === i ? (void 0 === L.selectorCursorPosition1 ? L.selectorCursorPosition1 = L.cursorPosition : L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()) : ("up" === i || "move" === i) && L.canSelectWithMouse && v.mouse.isDown && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()), "up" === i && (v.mouse.isDown = !1, L.selectorCursorPosition1 === L.selectorCursorPosition2 && L.resetSelectedArea())) }), T.checkKeyDown = (e => { e.preventDefault(); const t = e.key; if (O.__focused) { L.canSelectWithMouse = !1; const e = v.keys.ctrl, n = v.keys.shft; "Enter" === t ? T.placeNewLine() : "Home" === t ? T.goToLineStart(n) : "End" === t ? T.goToLineEnd(n) : "PageUp" === t ? T.goUpByHeight(n) : "PageDown" === t ? T.goDownByHeight(n) : "Backspace" === t ? e ? T.deleteBackwardsWithControl() : T.deleteBackwards() : "Delete" === t ? e ? T.deleteForwardsWithControl() : T.deleteForwards() : "ArrowLeft" === t ? e ? T.navigateLeftWithControl(n) : T.navigateLeft(n) : "ArrowRight" === t ? e ? T.navigateRightWithControl(n) : T.navigateRight(n) : "ArrowUp" === t ? T.navigateUp(n) : "ArrowDown" === t ? T.navigateDown(n) : "Escape" === t ? T.cancelSelecton() : "Control" === t ? v.keys.ctrl = !0 : "Shift" === t ? v.keys.shft = !0 : e ? T.checkCommand(t) : T.placeLetter(t) } }), T.checkKeyUp = (e => { e.preventDefault(); const t = e.key; O.__focused && ("Control" === t ? v.keys.ctrl = !1 : "Shift" === t && (v.keys.shft = !1)) }), T.cancelSelecton = (() => { L.hasSelectedArea() && L.resetSelectedArea() }), T.goDownByHeight = (e => { if (!e && L.hasSelectedArea() && L.resetSelectedArea(), e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.currentLine === L.lines.length - 1) return; const t = L.currentLine * O.__lineHeight + A.innerHeight; L.getCursorPosition(L.currentLineCursorPixels, t), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.goUpByHeight = (e => { if (!e && L.hasSelectedArea() && L.resetSelectedArea(), e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), 0 === L.currentLine) return; const t = L.currentLine * O.__lineHeight - A.innerHeight; L.getCursorPosition(L.currentLineCursorPixels, t), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.goToLineStart = (e => { if (!e && L.hasSelectedArea() && L.resetSelectedArea(), L.currentLineCursorPosition === L.lines[L.currentLine].length && L.currentLine < L.lines.length - 1 && !L.lineBreaks.includes(L.currentLine)) return; e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition); const t = L.currentLine * O.__lineHeight; L.getCursorPosition(0, t), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.goToLineEnd = (e => { let t, n; if (!e && L.hasSelectedArea() && L.resetSelectedArea(), e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), x.save(), x.font = A.fontFamily, L.lineBreaks.includes(L.currentLine) || L.currentLine === L.lines.length - 1) t = F(L.lines[L.currentLine]), n = L.currentLine * O.__lineHeight; else if (L.currentLineCursorPosition === L.lines[L.currentLine].length) { const e = L.currentLine + 1; if (L.lineBreaks.includes(e) || e === L.lines.length - 1) t = F(L.lines[e]), n = e * O.__lineHeight; else { const i = L.lines[e]; t = F(i.substr(0, i.length - 1)), n = e * O.__lineHeight } } else { const e = L.lines[L.currentLine]; t = F(e.substr(0, e.length - 1)), n = L.currentLine * O.__lineHeight } x.restore(), L.getCursorPosition(t, n), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.deleteForwards = (() => { if (L.hasSelectedArea()) { const e = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, e), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition, L.resetSelectedArea(), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine] } else L.cursorPosition < L.contents.length && (L.contents.splice(L.cursorPosition, 1), L.getLinesFromContent()); L.getContentPositions() }), T.deleteForwardsWithControl = (() => { if (L.hasSelectedArea()) { const e = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, e), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition, L.resetSelectedArea(), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine] } else if (L.cursorPosition < L.contents.length) { const e = L.getNextCursorPosition(L.contents, L.cursorPosition) - L.cursorPosition; L.contents.splice(L.cursorPosition, e), L.getLinesFromContent() } L.getContentPositions() }), T.deleteBackwards = (() => { if (L.hasSelectedArea()) { const e = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, e), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition, L.resetSelectedArea() } else L.cursorPosition > 0 && (L.cursorPosition--, L.contents.splice(L.cursorPosition, 1), L.getLinesFromContent()); L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.deleteBackwardsWithControl = (() => { if (L.hasSelectedArea()) { const e = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, e), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition, L.resetSelectedArea() } else if (L.cursorPosition > 0) { const e = L.getPrevCursorPosition(L.contents, L.cursorPosition), t = L.cursorPosition - e; L.cursorPosition = e, L.contents.splice(L.cursorPosition, t), L.getLinesFromContent() } L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.navigateLeft = (e => { !e && L.hasSelectedArea() ? (L.cursorPosition = L.minSelectionPosition, L.resetSelectedArea()) : L.cursorPosition > 0 && (e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.cursorPosition--, e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea())), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.navigateLeftWithControl = (e => { !e && L.hasSelectedArea() ? (L.cursorPosition = L.maxSelectionPosition, L.resetSelectedArea()) : L.cursorPosition > 0 && (e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.cursorPosition = L.getPrevCursorPosition(L.contents, L.cursorPosition), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea())), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.navigateRight = (e => { !e && L.hasSelectedArea() ? (L.cursorPosition = L.maxSelectionPosition, L.resetSelectedArea()) : L.cursorPosition < L.contents.length && (e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.cursorPosition++, e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea())), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.navigateRightWithControl = (e => { !e && L.hasSelectedArea() ? (L.cursorPosition = L.maxSelectionPosition, L.resetSelectedArea()) : L.cursorPosition < L.contents.length && (e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.cursorPosition = L.getNextCursorPosition(L.contents, L.cursorPosition), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea())), L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.navigateUp = (e => { if (!e && L.hasSelectedArea() && (L.cursorPosition = L.minSelectionPosition, L.resetSelectedArea()), L.cursorPosition > 0) { let t; e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.currentLineCursorPosition === L.lines[L.currentLine].length && L.currentLine < L.lines.length - 1 && !L.lineBreaks.includes(L.currentLine) ? (t = L.currentLine, L.intendedCursorPixels = 0) : t = L.currentLine - 1; const n = t * O.__lineHeight; L.getCursorPosition(L.intendedCursorPixels, n), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()) } L.getContentPositions() }), T.navigateDown = (e => { if (!e && L.hasSelectedArea() && (L.cursorPosition = L.maxSelectionPosition, L.resetSelectedArea()), L.cursorPosition < L.contents.length) { let t; e && void 0 === L.selectorCursorPosition1 && (L.selectorCursorPosition1 = L.cursorPosition), L.currentLineCursorPosition === L.lines[L.currentLine].length && L.currentLine < L.lines.length - 1 && !L.lineBreaks.includes(L.currentLine) ? (t = L.currentLine + 2, L.intendedCursorPixels = 0) : t = L.currentLine + 1; const n = t * O.__lineHeight; L.getCursorPosition(L.intendedCursorPixels, n), e && (L.selectorCursorPosition2 = L.cursorPosition, L.getSelectedArea()) } L.getContentPositions() }), T.placeLetter = (e => { if (!(e.length > 1)) { if (L.hasSelectedArea()) { const t = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, t, e), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition + 1, L.resetSelectedArea() } else L.contents.splice(L.cursorPosition, 0, e), L.getLinesFromContent(), L.cursorPosition++; L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() } }), T.placeString = (e => { if (L.hasSelectedArea()) { const t = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, t, ...e), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition + e.length, L.resetSelectedArea() } else L.contents.splice(L.cursorPosition, 0, ...e), L.getLinesFromContent(), L.cursorPosition += e.length; L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }), T.placeNewLine = (() => { if (!1 !== v.multiline) { if (L.hasSelectedArea()) { const e = L.getSelectedText().length; L.contents.splice(L.minSelectionPosition, e, L.newLineCode), L.getLinesFromContent(), L.cursorPosition = L.minSelectionPosition + 1, L.resetSelectedArea() } else L.contents.splice(L.cursorPosition, 0, L.newLineCode), L.getLinesFromContent(), L.cursorPosition++; L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() } }), T.checkCommand = (e => { if (!(e.length > 1)) switch (e.toLowerCase()) { case "x": T.cutSelectedArea(); break; case "c": T.copySelectedArea(); break; case "v": T.pasteSelectedArea(); break; case "a": T.selectAllContent() } }), T.cutSelectedArea = (() => { if (!L.hasSelectedArea()) return; const n = L.getSelectedText(); e(n), t(n), T.deleteBackwards() }), T.copySelectedArea = (() => { if (!L.hasSelectedArea()) return; const n = L.getSelectedText(); e(n), t(n) }), T.pasteSelectedArea = (() => { const e = Le.clipboard; "" !== e && T.placeString(e) }), T.selectAllContent = (() => { L.selectorCursorPosition1 = 0, L.selectorCursorPosition2 = L.contents.length, L.getSelectedArea(), L.cursorPosition = L.contents.length, L.intendedCursorPixels = L.getWidthAtIndex(L.lines[L.currentLine], L.currentLineCursorPosition) + L.linesAligned[L.currentLine], L.getContentPositions() }) }() } const M = {}; M.getText = (() => L.contents.join("")), M.clearText = (e => { L.contents.length = 0, !1 !== e && L.getLinesFromContent(), L.getContentPositions() }), M.appendText = ((e, t) => { L.contents.push(...e.split("")), !1 !== t && L.getLinesFromContent(), L.getContentPositions() }), M.prependText = ((e, t) => { L.contents.unshift(...e.split("")), !1 !== t && L.getLinesFromContent(), L.getContentPositions() }), M.removeTextLinesFromTop = ((e, t) => { for (let t = 0; t < e; t++) { const e = L.contents.indexOf(L.newLineCode); -1 === e ? M.clearText() : L.contents.splice(0, e + 1) } !1 !== t && L.getLinesFromContent(), L.getContentPositions() }), M.removeTextLinesFromBottom = ((e, t) => { for (let t = 0; t < e; t++) { const e = L.contents.lastIndexOf(L.newLineCode); -1 === e ? M.clearText() : L.contents.splice(e) } !1 !== t && L.getLinesFromContent(), L.getContentPositions() }); const E = {}; E.getText = (() => M.getText()), E.setText = (e => { "string" == typeof e && (M.clearText(!1), M.appendText(e)) }), E.clearText = (() => { M.clearText() }), E.addText = (e => { "string" == typeof e && M.appendText(e) }), E.addTextLn = (e => { "string" == typeof e && M.appendText(e + "\n") }), E.removeTextLn = ((e = 1) => { "number" == typeof e && (e < 0 ? M.removeTextLinesFromBottom(Math.abs(e)) : e > 0 && M.removeTextLinesFromTop(e)) }); const j = {}; j.drawText = ((e, ...t) => { "password" === O.__type && (e = e.replace(/[\s\S]/g, "*")), x.fillText(e, ...t) }), j.renderText = (() => { "dynamic" !== O.__type && L.hasSelectedArea() ? j.renderTextSelected() : j.renderTextPlain() }), j.renderTextPlain = (() => { if (x.save(), x.font = A.fontFamily, "none" === O.__fontColor) return; x.fillStyle = O.__fontColor; const e = Math.max(0, Math.floor((Math.abs(A.__contentY) - O.__lineHeight) / O.__lineHeight)), t = Math.min(L.lines.length, Math.floor((Math.abs(A.__contentY) + 2 * O.__lineHeight + A.innerHeight) / O.__lineHeight)); for (let n = e; n < t; n++) { const e = L.lines[n], t = L.linesAligned[n], i = A.innerX + A.contentX + t; j.drawText(e, i, A.innerY + A.contentY + n * O.__lineHeight) } x.restore() }), "dynamic" !== O.__type && (j.renderTextSelected = (() => { x.save(), x.font = A.fontFamily, x.fillStyle = "black"; const e = Math.max(0, Math.floor((Math.abs(A.__contentY) - O.__lineHeight) / O.__lineHeight)), t = Math.min(L.lines.length, Math.floor((Math.abs(A.__contentY) + 2 * O.__lineHeight + A.innerHeight) / O.__lineHeight)); let n, i = 0; for (let t = 0; t < e; t++)i += L.lines[t].length, L.lineBreaks.includes(t) && i++; for (let o = e; o < t; o++) { const e = L.lines[o], t = e.length; let r = !1; const s = L.linesAligned[o]; void 0 === n && i + t >= L.minSelectionPosition && (r = !0, n = !0), n && i + t >= L.maxSelectionPosition && (r = !0, n = !1), n && (r = !0); const c = A.innerX + A.contentX + s; if (r) { x.save(); let t = c; const n = A.innerY + A.contentY + o * O.__lineHeight; let r = 0; const s = O.__lineHeight, a = e; for (const e of a) r = F(e), i >= L.minSelectionPosition && i < L.maxSelectionPosition ? (x.fillStyle = "blue", x.fillRect(Math.ceil(t), n, Math.ceil(r), s), x.fillStyle = "white", j.drawText(e, t, n)) : "none" !== O.__fontColor && (x.fillStyle = O.__fontColor, j.drawText(e, t, n)), t += r, i++; x.restore() } else "none" !== O.__fontColor && (x.fillStyle = O.__fontColor, j.drawText(e, c, A.innerY + A.contentY + o * O.__lineHeight)), i += t; L.lineBreaks.includes(o) && i++ } x.restore() }), j.renderCursor = (() => { if (O.__focused) { const e = Math.max(Math.round(A.innerX + 1), Math.min(Math.round(A.innerX + L.currentLineCursorPixels + A.contentX), Math.round(A.innerX + A.innerWidth - 1))), t = A.innerY + A.contentY + L.currentLine * O.__lineHeight; x.fillStyle = "purple", L.currentLineCursorPosition === L.lines[L.currentLine].length && L.currentLine < L.lines.length - 1 && !L.lineBreaks.includes(L.currentLine) ? (x.fillRect(Math.round(A.innerX + A.contentX + L.linesAligned[L.currentLine + 1]), A.innerY + A.contentY + (L.currentLine + 1) * O.__lineHeight, 1, O.__size), x.fillRect(e, t + 1 * O.__size / 7, 1, O.__size / 7), x.fillRect(e, t + 3 * O.__size / 7, 1, O.__size / 7), x.fillRect(e, t + 5 * O.__size / 7, 1, O.__size / 7)) : x.fillRect(e, t, 1, O.__size) } })), j.renderBorder = (() => { x.lineWidth = 1, O.__focused && (x.strokeStyle = "blue", x.strokeRect(O.__x - 1 + .5, O.__y - 1 + .5, O.__width + 2, O.__height + 2)), "none" !== O.__borderColor && (x.strokeStyle = O.__borderColor, x.strokeRect(Math.round(O.__x) + .5, Math.round(O.__y) + .5, Math.round(O.__width), Math.round(O.__height))) }), j.renderBackground = (() => { "none" !== O.__backgroundColor && (x.fillStyle = O.__backgroundColor, x.fillRect(O.__x, O.__y, O.__width, O.__height)) }), j.clip = (() => { x.beginPath(), x.rect(A.innerX, A.innerY, A.innerWidth, A.innerHeight), x.closePath(), x.clip() }); const N = { __render: (e, t, n, i) => { x.save(), x.textBaseline = "top", j.renderBackground(), j.renderBorder(), j.clip(), j.renderText(), "dynamic" !== O.__type && j.renderCursor(), x.restore() }, __tick: () => { O.__hovered && k("text") } }, D = { ...E, ...P }; return v.initialize(), { props: D, __privateProps: N } }, Z = function (e, t, n) { const i = {}, { props: o, __privateProps: r } = U(e); let s = !1, c = 0, a = 0, l = 0; if (Object.defineProperties(o, { _rotation: { get: function () { return c }, set: function (e) { c = "string" == typeof e && /^\d+%$/.test(e) ? parseInt(e) / 100 * 360 : parseInt(e), h.inRange(c, -179, 180) || (c = h.wheelClamp(c, -180, 180)) }, enumerable: !0, configurable: !1 }, _anchorX: { get: function () { return a * o._width }, set: function (e) { a = "string" == typeof e && /^\d+%$/.test(e) ? parseInt(e) / 100 : e / (o._width || 1) }, enumerable: !0, configurable: !1 }, _anchorY: { get: function () { return l * o._height }, set: function (e) { l = "string" == typeof e && /^\d+%$/.test(e) ? parseInt(e) / 100 : e / (o._height || 1) }, enumerable: !0, configurable: !1 } }), e) { if (!_.isObject(e)) return; for (const t of Object.keys(e)) _.isDefined(o[t]) && (o[t] = e[t]) } const d = { scripts: [] }, f = [], g = []; if (_.isScriptOrFunction(t)) f.push($.getScriptOrFunction(t)); else if (_.isArray(t)) for (const e of Object.keys(t)) { const n = t[e]; _.isScriptOrFunction(n) && f.push($.getScriptOrFunction(n)) } const m = function () { const { _x: e, _y: t, _width: n, _height: i, _rotation: r, _anchorX: s, _anchorY: c } = o, a = -s, l = -c, u = n - s, d = i - c; let f, p, _, g; 0 === r ? (f = h.newPoint(a, l), p = h.newPoint(a, d), _ = h.newPoint(u, l), g = h.newPoint(u, d)) : (f = h.rotatePoint(a, l, r), p = h.rotatePoint(a, d, r), _ = h.rotatePoint(u, l, r), g = h.rotatePoint(u, d, r)); const m = h.minMax("_x", "min", f, _, p, g), y = h.minMax("_y", "min", f, _, p, g); return { _x: m + e, _y: y + t, _width: h.minMax("_x", "max", f, _, p, g) - m, _height: h.minMax("_y", "max", f, _, p, g) - y } }, y = e => { for (const t of Object.keys(e)) i[t] = e[t] }, C = () => { for (const e of Object.keys(i)) delete i[e] }, w = { ___overrideProps: e => { if (_.isObject(e)) for (const t of Object.keys(e)) _.isDefined(o[t]) && (o[t] = e[t]) }, ___getInit: () => f, ___getType: () => _.typeOf(b), ___getProps: () => ({ ...o }), ___getBounds: m, _isMouseInFlevaClip: (e, t) => { if (!o._visible) return !1; const n = o, i = $.getRotatedMappedPoint({ _x: e, _y: t }, o); return !!$.boxHitTestPoint(n, i) }, __start: () => { }, __stop: () => { }, __load: async () => { if (!s) { if (f.length > 0) for (const e of Object.keys(f)) { const t = f[e].bind(b), n = await t(b); _.isScriptOrFunction(n) && g.push($.getScriptOrFunction(n)) } r.__load && r.__load(), s = !0 } }, __unload: async () => { if (s) { if (g.length > 0) { for (const e of Object.keys(g)) { const t = g[e].bind(b); await t(b) } g.length = 0 } d.scripts.length = 0, r.__unload && r.__unload(), s = !1 } }, __tick: async () => { for (const e of Object.keys(d.scripts)) { const t = d.scripts[e]; await t(b) } r.__tick() }, __render: () => { $.renderFlevaClip({ ...o, _bounds: m() }, r.__render) } }; r.___setSelection && (w.___setSelection = r.___setSelection); const S = new u.TextField({ state: i, hitTestFlevaClip: (e, t) => { let n; if (_.isFlevaClip(e)) n = e; else { if (!_.isString(e)) throw "Invalid flevaclip argument! FlevaClip or string expected."; n = ee(e) } if (!n) throw `FlevaClip with instance name ${e} not found.`; const i = o, r = n.__private__.___getProps(), s = m(), c = n.__private__.___getBounds(); return !(!i._visible || !r._visible || !$.boxHitTest(s, c)) }, hitTestPoint: (e, t, n) => { if (!_.isNumber(e)) throw "Number expected for _x point."; if (!_.isNumber(t)) throw "Number expected for _y point."; const i = o, r = { _x: e, _y: t }; if (!i._visible) return !1; if (n) { const e = $.getRotatedMappedPoint(r, o); return $.boxHitTestPoint(i, e) } { const e = m(); return $.boxHitTestPoint(e, r) } }, changeState: (e, t) => { const n = {}; n[e] = t, y(n) }, useState: e => { if (_.isObject(e)) { const t = e; C(), y(t) } else if (_.isScriptOrFunction(e)) { const t = p.deepCloneObject(i), n = $.getScriptOrFunction(e)(t); C(), y(n) } }, setState: e => { if (_.isObject(e)) y(e); else if (_.isScriptOrFunction(e)) { const t = p.deepCloneObject(i), n = $.getScriptOrFunction(e)(t); y(n) } }, addScript: e => { if (_.isString(e)) { const t = ae(e); d.scripts.push(G(t).bind(b)) } else if (_.isScriptOrFunction(e)) { const t = $.getScriptOrFunction(e); d.scripts.push(G(t).bind(b)) } }, localToGlobal: e => ({ _x: e._x + o._x, _y: e._y + o._y }), localRelativeToGlobal: e => { const t = h.rotatePoint(e._x, e._y, -o._rotation); return { _x: t._x + o._x, _y: t._y + o._y } }, globalToLocal: e => ({ _x: e._x - o._x, _y: e._y - o._y }), globalToLocalRelative: e => h.rotatePoint(e._x - o._x, e._y - o._y, o._rotation), swapDepths: e => { n && n.swapDepths && n.swapDepths(e) } }); Object.defineProperties(S, { __private__: { get: function () { return w }, enumerable: !1, configurable: !1 } }); for (let e of Object.keys(o)) Object.defineProperty(S, e, { get: function () { return o[e] }, set: function () { o[e] = arguments[0] }, enumerable: !0, configurable: !1 }); const b = S; return S }, z = function (e = { _x: 0, _y: 0, _width: 50, _height: 50, _alpha: 1, _visible: !0, _rotation: 0, _anchorX: 0, _anchorY: 0 }, t, n) { const i = {}, o = { _x: 0, _y: 0, _width: 50, _height: 50, _alpha: 1, _visible: !0, _rotation: 0, _anchorX: 0, _anchorY: 0 }; let r = null, s = !1, c = 0, a = 0, l = 0; Object.defineProperties(o, { _rotation: { get: function () { return c }, set: function (e) { c = "string" == typeof e && /^\d+%$/.test(e) ? parseInt(e) / 100 * 360 : parseInt(e), h.inRange(c, -179, 180) || (c = h.wheelClamp(c, -180, 180)) }, enumerable: !0, configurable: !1 }, _anchorX: { get: function () { return a * o._width }, set: function (e) { a = "string" == typeof e && /^\d+%$/.test(e) ? parseInt(e) / 100 : e / (o._width || 1) }, enumerable: !0, configurable: !1 }, _anchorY: { get: function () { return l * o._height }, set: function (e) { l = "string" == typeof e && /^\d+%$/.test(e) ? parseInt(e) / 100 : e / (o._height || 1) }, enumerable: !0, configurable: !1 } }); const d = () => { _.isScriptOrFunction(r) && $.getScriptOrFunction(r)(k) }; if (e) { if (!_.isObject(e)) return; for (const t of Object.keys(e)) _.isDefined(o[t]) && (o[t] = e[t]) } const f = { scripts: [], visuals: { src: null, type: null, name: null } }, g = [], m = []; if (_.isScriptOrFunction(t)) g.push($.getScriptOrFunction(t)); else if (_.isArray(t)) for (const e of Object.keys(t)) { const n = t[e]; _.isScriptOrFunction(n) && g.push($.getScriptOrFunction(n)) } const y = function () { const { _x: e, _y: t, _width: n, _height: i, _rotation: r, _anchorX: s, _anchorY: c } = o, a = -s, l = -c, u = n - s, d = i - c; let f, p, _, g; 0 === r ? (f = h.newPoint(a, l), p = h.newPoint(a, d), _ = h.newPoint(u, l), g = h.newPoint(u, d)) : (f = h.rotatePoint(a, l, r), p = h.rotatePoint(a, d, r), _ = h.rotatePoint(u, l, r), g = h.rotatePoint(u, d, r)); const m = h.minMax("_x", "min", f, _, p, g), y = h.minMax("_y", "min", f, _, p, g); return { _x: m + e, _y: y + t, _width: h.minMax("_x", "max", f, _, p, g) - m, _height: h.minMax("_y", "max", f, _, p, g) - y } }, C = e => { for (const t of Object.keys(e)) i[t] = e[t] }, w = () => { for (const e of Object.keys(i)) delete i[e] }, S = []; let b = 0, x = void 0; const v = () => { _.isDefined(x) && (He(x), S.length = 0, b = 0, x = void 0), f.visuals.name = null, f.visuals.src = null, f.visuals.type = null }, P = { ___overrideProps: e => { if (_.isObject(e)) for (const t of Object.keys(e)) _.isDefined(o[t]) && (o[t] = e[t]) }, ___getInit: () => g, ___getType: () => _.typeOf(L), ___getProps: () => ({ ...o }), ___getBounds: y, _isMouseInFlevaClip: (e, t) => { if (!o._visible) return !1; const n = o, i = $.getRotatedMappedPoint({ _x: e, _y: t }, o); return !!$.boxHitTestPoint(n, i) }, __start: () => { d() }, __stop: () => { v() }, __load: async () => { if (!s) { if (g.length > 0) for (const e of Object.keys(g)) { const t = g[e].bind(L), n = await t(L); _.isScriptOrFunction(n) && m.push($.getScriptOrFunction(n)) } d(), s = !0 } }, __unload: async () => { if (s) { if (m.length > 0) { for (const e of Object.keys(m)) { const t = m[e].bind(L); await t(L) } m.length = 0 } v(), f.scripts.length = 0, s = !1 } }, __tick: async () => { for (const e of Object.keys(f.scripts)) { const t = f.scripts[e]; await t(L) } }, __render: () => { f.visuals.type === _.typeOf(u.Sprite) || f.visuals.type === _.typeOf(u.SpriteSheet) ? $.renderFlevaClip({ ...o, _bounds: y(), _clip: !0 }, $.drawSprite, [f.visuals.src]) : f.visuals.type === _.typeOf(u.Graphic) ? $.renderFlevaClip({ ...o, _bounds: y(), _clip: !0 }, $.drawGraphic, [f.visuals.src]) : f.visuals.type === _.typeOf(u.Painting) && $.renderFlevaClip({ ...o, _bounds: y(), _clip: !0 }, $.drawPainting, [f.visuals.src]) } }, O = new u.Prefab({ state: i, hitTestFlevaClip: (e, t) => { let n; if (_.isFlevaClip(e)) n = e; else { if (!_.isString(e)) throw "Invalid flevaclip argument! FlevaClip or string expected."; n = ee(e) } if (!n) throw `FlevaClip with instance name ${e} not found.`; const i = o, r = n.__private__.___getProps(), s = y(), c = n.__private__.___getBounds(); return !(!i._visible || !r._visible || !$.boxHitTest(s, c)) }, hitTestPoint: (e, t, n) => { if (!_.isNumber(e)) throw "Number expected for _x point."; if (!_.isNumber(t)) throw "Number expected for _y point."; const i = o, r = { _x: e, _y: t }; if (!i._visible) return !1; const s = f.visuals.type === _.typeOf(u.Sprite) || f.visuals.type === _.typeOf(u.SpriteSheet); if (n && s) { const e = f.visuals.src; if (!e) return !1; const t = $.getPixelMap(e), n = { ...i, pixelMap: t }, s = $.getRotatedMappedPoint(r, o); if ($.boxHitTestPoint(n, s) && $.pixelHitTestPoint(n, s)) return !0 } else { const e = y(); if ($.boxHitTestPoint(e, r)) return !0 } return !1 }, changeState: (e, t) => { const n = {}; n[e] = t, C(n), d() }, useState: e => { if (_.isObject(e)) { const t = e; w(), C(t), d() } else if (_.isScriptOrFunction(e)) { const t = p.deepCloneObject(i), n = $.getScriptOrFunction(e)(t); w(), C(n), d() } }, setState: e => { if (_.isObject(e)) C(e), d(); else if (_.isScriptOrFunction(e)) { const t = p.deepCloneObject(i), n = $.getScriptOrFunction(e)(t); C(n), d() } }, addScript: e => { if (_.isString(e)) { const t = ae(e); f.scripts.push(G(t).bind(L)) } else if (_.isScriptOrFunction(e)) { const t = $.getScriptOrFunction(e); f.scripts.push(G(t).bind(L)) } }, setAppearance: e => { if (_.isString(e)) { const t = ae(e); r = G(t).bind(k) } else if (_.isScriptOrFunction(e)) { const t = $.getScriptOrFunction(e); r = G(t).bind(k) } }, localToGlobal: e => ({ _x: e._x + o._x, _y: e._y + o._y }), localRelativeToGlobal: e => { const t = h.rotatePoint(e._x, e._y, -o._rotation); return { _x: t._x + o._x, _y: t._y + o._y } }, globalToLocal: e => ({ _x: e._x - o._x, _y: e._y - o._y }), globalToLocalRelative: e => h.rotatePoint(e._x - o._x, e._y - o._y, o._rotation), swapDepths: e => { n && n.swapDepths && n.swapDepths(e) } }); Object.defineProperties(O, { __private__: { get: function () { return P }, enumerable: !1, configurable: !1 } }); for (let e of Object.keys(o)) Object.defineProperty(O, e, { get: function () { return o[e] }, set: function () { o[e] = arguments[0] }, enumerable: !0, configurable: !1 }); const L = O, k = { state: i, useSprite: e => { _.isSprite(e) && (e = e.idName), R.checkSpriteNotExist(e), f.visuals.type === _.typeOf(u.Sprite) && f.visuals.name === e || (v(), f.visuals.name = e, f.visuals.src = e, f.visuals.type = _.typeOf(u.Sprite)) }, useGraphic: e => { _.isGraphic(e) && (e = e.idName), R.checkGraphicNotExist(e), f.visuals.type === _.typeOf(u.Graphic) && f.visuals.name === e || (v(), f.visuals.name = e, f.visuals.src = e, f.visuals.type = _.typeOf(u.Graphic)) }, useSpriteSheet: (e, t = 1e3) => { _.isSpriteSheet(e) && (e = e.idName), R.checkSpriteSheetNotExist(e), f.visuals.type === _.typeOf(u.SpriteSheet) && f.visuals.name === e || (v(), S.push(...D.spritesheets[e].src), b = 0, x = Ne(() => { b = h.cycle(b, S.length - 1); const e = S[b]; f.visuals.src = e }, t, { _startNow: !1, _skipOlds: !0 }), f.visuals.name = e, f.visuals.src = S[b], f.visuals.type = _.typeOf(u.SpriteSheet)) }, usePainting: e => { if (_.isPainting(e) && (e = e.idName), _.isString(e)) { const t = e; if (R.checkPaintingNotExist(t), f.visuals.type === _.typeOf(u.Painting) && f.visuals.name === t) return; v(), f.visuals.name = t, f.visuals.src = t, f.visuals.type = _.typeOf(u.Painting) } else if (_.isScriptOrFunction(e)) { v(); const t = $.getScriptOrFunction(e); f.visuals.name = "painting", f.visuals.src = t.bind(H.ctx), f.visuals.type = _.typeOf(u.Painting) } } }; return O }, K = function (e, { _width: t = 100, _height: n = 100, cut: i = !1, _canHit: o = !0, props: s = [] } = {}, ...c) { return new Promise(async (a, l) => { const d = []; let h, g, m, y; async function C(e, i, r, s, c) { if (s) for (let e = 0; e < i; e += t) { y.clearRect(0, 0, t, n), y.drawImage(h, e, 0, t, n, 0, 0, t, n); const i = await Q(m); let r; if (o) { r = { data: q(m, y), _width: m.width, _height: m.height } } const s = new u.Sprite({ src: i, pixelMap: r }), c = f("spritesheet"); D.sprites[c] = s, d.push(c) } else { y.clearRect(0, 0, t, n), y.drawImage(h, 0, 0, t, n, 0, 0, t, n); const e = await Q(m); let i; if (o) { i = { data: q(m, y), _width: m.width, _height: m.height } } const r = new u.Sprite({ src: e, pixelMap: i }), s = f("spritesheet"); D.sprites[s] = r, d.push(s) } } m = document.createElement("canvas"), y = m.getContext("2d"), m.width = t, m.height = n; for (const a of Object.keys(c)) { let l, u = c[a]; const f = s[a], m = _.isDefined(f) && _.isDefined(f._width) ? f._width : t, y = _.isDefined(f) && _.isDefined(f._height) ? f._height : n, w = _.isDefined(f) && _.isDefined(f.cut) ? f.cut : i; if (_.isSpriteSheet(u)) try { let r; r = u.src ? u.src : ue(u.idName).src; const s = p.multiplyObject({ _width: m, _height: y, cut: w }, r.length), c = await K(e, { _width: t, _height: n, cut: i, _canHit: o, props: s }, ...r); d.push(...c.src) } catch{ } else { const [t, n] = [0, 0]; if (_.isScriptOrFunction(u)) try { g = (h = document.createElement("canvas")).getContext("2d"), h.width = m, h.height = y, (u = $.getScriptOrFunction(u).bind(g))(g, t, n, m, y), l = !0 } catch{ } else if (_.isGraphic(u)) try { let e; e = u.src ? u.src : de(u.idName).src, g = (h = document.createElement("canvas")).getContext("2d"), h.width = m, h.height = y, g.imageSmoothingEnabled = !1, g.drawImage(e, t, n, m, y), l = !0 } catch{ } else if (_.isString(u)) try { let e; e = u.src ? u.src : le(u).src, g = (h = document.createElement("canvas")).getContext("2d"), h.width = m, h.height = y, g.imageSmoothingEnabled = !1, g.drawImage(e, t, n, m, y), l = !0 } catch{ } else if (_.isSprite(u)) try { let e; e = u.src ? u.src : le(u.idName).src, g = (h = document.createElement("canvas")).getContext("2d"), h.width = m, h.height = y, g.imageSmoothingEnabled = !1, g.drawImage(e, t, n, m, y), l = !0 } catch{ } else if (_.isPainting(u)) try { let e; e = u.src ? u.src : fe(u.idName).src, g = (h = document.createElement("canvas")).getContext("2d"), h.width = m, h.height = y, (e = e.bind(g))(g, t, n, m, y), l = !0 } catch{ } if (!l) { console.warn(`No sprite method found for "${e}". Using default backup.`); const i = r.sprite; g = (h = document.createElement("canvas")).getContext("2d"), h.width = m, h.height = y, g.imageSmoothingEnabled = !1, g.drawImage(i, t, n, m, y) } await C(0, m, 0, w) } } a(new u.SpriteSheet({ idName: e, src: d })) }) }, Q = function (e) { return new Promise((t, n) => { const i = new r.Image(e.width, e.height); i.onload = function () { t(i) }, i.onerror = function () { console.warn("Graphic load failed. Using default backup."), t(r.unknowngraphic) }, i.src = e.toDataURL() }) }, q = function (e, t) { const n = []; for (let i = 0; i < e.height; i += m)for (let o = 0; o < e.width; o += m) { const e = o + "_" + i, r = t.getImageData(o, i, 1, 1).data[3]; n[e] = r } return n }, J = function (e) { return R.checkFlevaClipNotExist(e), D.flevaclips[e].instance }, ee = e => { if ("" !== B.scene) { const t = D.scenes[B.scene].__private__.___getFlevaClipByInstanceName(e); if (t) return t } for (const t of Object.keys(oe)) if (oe[t].instanceName === e) return oe[t].instance; return {} }, te = e => { for (const t of Object.keys(e)) g[t] = e[t] }, ne = () => { for (const e of Object.keys(g)) delete g[e] }, ie = function (e, ...t) { const n = t[0]; R.checkFlevaClipExist(n); let i = {}, o = V; _.isObject(t[1]) && _.isScriptOrFunction(t[2]) ? (i = t[1] || {}, o = $.getScriptOrFunction(t[2])) : _.isScriptOrFunction(t[1]) ? o = $.getScriptOrFunction(t[1]) : _.isObject(t[1]) && (i = t[1] || {}); const r = "prefab" === e ? z : "textfield" === e && Z; D.flevaclips[n] = { instance: r(i, o), type: e } }, oe = {}, re = async (e, t, n, i, o) => { const r = f("stack"), s = { swapDepths: e => y.swapDepths(r, e) }, c = "prefab" === e ? z : "textfield" === e && Z; oe[t] = { stackName: r, instanceName: n, instance: c(i, o, s) }, y.list[y.list.length] = { stackName: r, depth: 1, instance: oe[t].instance, render: function () { this.instance.__private__.__render() } }, y.sortList(), await oe[t].instance.__private__.__load() }, se = async (e, ...t) => { let n, i, o, r, s = {}, c = !1; if (t.length > 1 && _.isString(t[t.length - 1]) && (n = t[t.length - 1]), n ? R.checkCanUseName(n, "prefab") : n = f("prefab"), _.isString(t[0])) { const a = t[0]; _.isObject(t[1]) && _.isScriptOrFunction(t[2]) ? (s = t[1] || {}, i = $.getScriptOrFunction(t[2])) : _.isScriptOrFunction(t[1]) ? i = $.getScriptOrFunction(t[1]) : _.isObject(t[1]) && (s = t[1] || {}); const { instanceName: l, preserve: u = !1, ...d } = s;[o, c, r] = [l, u, d]; const f = J(a).__private__, h = f.___getType(); if (e !== h) throw `Expected ${e} flevaclip but received ${h} instead.`; let p = f.___getInit(); i && (p = [...p, i]); const g = f.___getProps(); await re(e, n, o, { ...g, ...r }, p) } else if (_.isObject(t[0]) && _.isScriptOrFunction(t[1])) { s = t[0] || {}; const i = $.getScriptOrFunction(t[1]), { instanceName: a, preserve: l = !1, ...u } = s;[o, c, r] = [a, l, u], await re(e, n, o, r, i) } else if (_.isScriptOrFunction(t[0])) { const i = $.getScriptOrFunction(t[0]), { instanceName: a, preserve: l = !1, ...u } = s;[o, c, r] = [a, l, u], await re(e, n, o, r, i) } else if (_.isObject(t[0])) { s = t[0] || {}; const i = V, { instanceName: a, preserve: l = !1, ...u } = s;[o, c, r] = [a, l, u], await re(e, n, o, r, i) } }, ce = async function (e, t) { if (oe[t]) { const n = oe[t]; if (e !== n.instance.__private__.___getType()) return; const i = y.list.findIndex(e => e.stackName === n.stackName); -1 !== i && y.list.splice(i, 1), await n.instance.__private__.__unload(), delete oe[t] } }, ae = function (e) { return R.checkScriptNotExist(e), D.scripts[e] }, le = function (e) { return R.checkSpriteNotExist(e), D.sprites[e] }, ue = function (e) { return R.checkSpriteSheetNotExist(e), D.spritesheets[e] }, de = function (e) { return R.checkGraphicNotExist(e), D.graphics[e] }, fe = function (e) { return R.checkPaintingNotExist(e), D.paintings[e] }; let he = void 0; const pe = () => void 0 !== he, _e = e => { he = e }, ge = () => { pe() && _e(he()) }, me = async function () { "default" !== H.div.style.cursor && k("default"); for (const e of Object.keys(B.scripts)) { const t = B.scripts[e]; await t(Ve) } for (const e of Object.keys(oe)) await oe[e].instance.__private__.__tick(); try { "" !== B.scene && await D.scenes[B.scene].__private__.__tick() } catch (e) { console.error("Error on engine tick:", e) } }; let ye = 0, Ce = 0, we = { fps: 0, spf: 0 }; const Se = async function () { (() => { if (ke.isPressed("left")) { const e = [...y.list].reverse(); ge(); for (const t of Object.keys(e)) { const n = e[t].instance; if (n.__private__.___setSelection && n.__private__._isMouseInFlevaClip(Me._xmouse, Me._ymouse) && (_e(n.__private__.___setSelection(Me._xmouse, Me._ymouse)), pe())) break } pe() && (L(), j()) } pe() && (L(), j(!0)) })(), await me(), L(), j(), I.showingPage && (H.ctx.clearRect(0, 0, H.canvas.width, H.canvas.height), H.ctx.fillStyle = r.stage._color, H.ctx.fillRect(0, 0, H.canvas.width, H.canvas.height), function () { "" !== B.scene && D.scenes[B.scene].__private__.__render(); for (const e of Object.keys(y.list)) y.list[e].render() }()) }; let be = !1; const xe = function (e) { if ("false" === Be.state && Be.performload(), "loaded" === Be.state) return console.error("App loaded. Press any key to continue."); if ("ready" !== Be.state) return console.error("Can't start app. Loading not complete."); ve(), be = !0, "" !== B.scene && D.scenes[B.scene].__private__.__start(); for (const e of Object.keys(oe)) oe[e].instance.__private__.__start(); let t = performance.now(), n = 0, i = 0; ye = Ne(async () => { const e = performance.now(); await Se(); const o = performance.now(); i = Math.round(10 * (o - e)) / 1e4, n = Math.round(1e3 / (o - t || 1)), t = o }, 1e3 / e, { _skipOlds: !0 }), Ce = Ne(() => { we.fps = n, we.spf = i }, 1e3) }, ve = function () { He(ye), He(Ce); for (const e of Object.keys(oe)) oe[e].instance.__private__.__stop(); "" !== B.scene && D.scenes[B.scene].__private__.__stop(), be = !1 }, Pe = function (e) { e.preventDefault(), e.stopPropagation() }, Oe = function () { document.hidden ? I.showingPage = !1 : I.showingPage = !0 }, Le = { clipboard: "", get version() { return r.engine.version }, get loops() { return X.loops }, get FLEVAR_ENV() { return r.flevar_env }, get takeScreenShot() { return s } }, ke = function () { const e = function (e) { return "string" == typeof e && (e = e.toLowerCase()), "left" === e || 0 === e ? w._left || !1 : "middle" === e || 1 === e ? w._middle || !1 : ("right" === e || 2 === e) && w._right || !1 }, t = new u.Mouse({ isDown: e, isUp: function (t) { return !e(t) }, isPressed: function (e) { return "string" == typeof e && (e = e.toLowerCase()), "left" === e || 0 === e ? S._left || !1 : "middle" === e || 1 === e ? S._middle || !1 : ("right" === e || 2 === e) && S._right || !1 }, isReleased: function (e) { return "string" == typeof e && (e = e.toLowerCase()), "left" === e || 0 === e ? b._left || !1 : "middle" === e || 1 === e ? b._middle || !1 : ("right" === e || 2 === e) && b._right || !1 }, show: function () { k("default"), w.isHidden && (w.isHidden = !1) }, hide: function () { k("none"), w.isHidden || (w.isHidden = !0) }, LEFT: 0, MIDDLE: 1, RIGHT: 2 }); return Object.defineProperties(t, { hidden: { get: function () { return w.isHidden }, enumerable: !1, configurable: !1 }, _x: { get: function () { return C._x }, enumerable: !1, configurable: !1 }, _y: { get: function () { return C._y }, enumerable: !1, configurable: !1 } }), t }(), Ae = function () { const e = { space: " ", left: "arrowleft", up: "arrowup", right: "arrowright", down: "arrowdown", ctrl: "control", alternate: "alt" }, t = function (t) { return "string" == typeof t && (t = t.toLowerCase(), e[t] && (t = e[t])), A["code_" + t] || A["name_" + t] || !1 }; return new u.Key({ isDown: t, isUp: function (e) { return !t(e) }, isPressed: function (t) { return "string" == typeof t && (t = t.toLowerCase(), e[t] && (t = e[t])), F["code_" + t] || F["name_" + t] || !1 }, isReleased: function (t) { return "string" == typeof t && (t = t.toLowerCase(), e[t] && (t = e[t])), T["code_" + t] || T["name_" + t] || !1 }, LEFT: 37, RIGHT: 39, UP: 38, DOWN: 40, SPACE: 32, BACKSPACE: 8, ENTER: 13, TAB: 9, SHIFT: 16, CONTROL: 17, CTRL: 17, ALTERNATE: 18, ALT: 18, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90 }) }(), Fe = function () { let e = D.sounds, t = 1; const n = function (e, { _path: t = r.soundPath, _type: i = r.soundType, _name: o, _src: c } = {}, { clone: a = !1, unknown: l = !1 } = {}) { return new Promise((d, f) => { const h = c || `${t}/${o || e}.${i}`, p = new r.Audio(h); p.onended = (() => s(e)), p.onloadeddata = function () { const t = new u.Sound({ idName: e, src: p, clone: a, unknown: l }); t.volume = 1, d(t) }, p.onerror = async function () { const t = `Sound load for "${e}" failed.`, i = r.useUnknownSound(); if (!i) return console.warn(`${t} Default backup not supported in this browser. Sound not created.`), d(); console.warn(`${t} Using default backup.`); const o = await n(e, { _src: i }, { clone: a, unknown: !0 }); d(o) } }) }, i = function (e) { return _.isSound(e) ? e.idName : e }, o = function (e) { if (!_.isScriptOrFunction(l.onerror)) throw e; $.getScriptOrFunction(l.onerror)(e) }, s = function (t) { e[t].unknown && console.warn("Default sound file ended."), e[t].clone && c(t) }, c = function (t) { try { if (_.isSound(t)) { delete e[t.idName]; try { t.constructor = Object } catch (e) { throw e } } else R.checkSoundNotExist(t), delete e[t] } catch (e) { return o(`Cannot remove sound: ${e.msg || e}`) } }, a = function (t) { return t = i(t), e[t] ? e[t].src.paused : o(`Cannot get paused for "${t}": Sound file does not exist.`) }, l = new u.Sound({ create: async function (t, i) { try { R.checkSoundExist(t), e[t] = await n(t, i) } catch (e) { return o(`Cannot create "${t}": ${e.msg || e}`) } }, remove: c, play: async function (t) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; await e[t].src.play() } catch (e) { return o(`Cannot play "${t}": ${e.msg || e}`) } }, pause: function (t) { if (t = i(t), !e[t]) return o(`Cannot pause "${t}": Sound file does not exist.`); e[t].src.pause() }, stop: function (t) { if (t = i(t), !e[t]) return o(`Cannot stop "${t}": Sound file does not exist.`); a(t) || e[t].src.pause(), e[t].src.currentTime = 0, e[t].src.loop = !1, a(t) || s(t) }, restart: async function (t) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; e[t].src.pause(), e[t].src.currentTime = 0, await e[t].src.play() } catch (e) { return o(`Cannot restart "${t}": ${e.msg || e}`) } }, skipForward: function (t, n) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; const { currentTime: r, duration: s } = e[t].src; n = r + n > s ? s - r : n, e[t].src.currentTime += n } catch (e) { return o(`Cannot skip "${t}" forward: ${e.msg || e}`) } }, skipBackward: function (t, n) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; const { currentTime: r, duration: s } = e[t].src; n = r - n < 0 ? r : n, e[t].src.currentTime -= n } catch (e) { return o(`Cannot skip "${t}" backward: ${e.msg || e}`) } }, playLoop: async function (t) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; await e[t].src.play(), e[t].src.loop = !0 } catch (e) { return o(`Cannot play "${t}": ${e.msg || e}`) } }, playOnce: async function (t) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; e[t].src.pause(), e[t].src.currentTime = 0, await e[t].src.play(), e[t].src.loop = !1 } catch (e) { return o(`Cannot play "${t}": ${e.msg || e}`) } }, playClone: async function (t) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; const r = f("sound"); return e[r] = await n(r, { _src: e[t].src.src }, { clone: !0, unknown: e[t].unknown }), await e[r].src.play(), je(r) } catch (e) { return o(`Cannot playyyy "${t}": ${e.msg || e}`) } }, duplicate: async function (t, r) { try { if (t = i(t), !e[t]) throw { msg: "Sound file does not exist." }; let s; return r ? (s = r, R.checkSoundExist(s)) : s = f("sound"), e[s] = await n(s, { _src: e[t].src.src }, { unknown: e[t].unknown }), je(s) } catch (e) { return o(`Cannot duplicate "${t}": ${e.msg || e}`) } }, mute: function (t) { if (t = i(t), !e[t]) return o(`Cannot mute "${t}": Sound file does not exist.`); e[t].src.muted = !0 }, unmute: function (t) { if (t = i(t), !e[t]) return o(`Cannot unmute "${t}": Sound file does not exist.`); e[t].src.muted = !1 }, togglemute: function (t) { if (t = i(t), !e[t]) return o(`Cannot toggle mute "${t}": Sound file does not exist.`); e[t].src.muted = !e[t].src.muted }, getVolume: function (n) { return n ? (n = i(n), e[n] ? e[n].src.volume : o(`Cannot set volume of "${n}": Sound file does not exist.`)) : t }, setVolume: function (n, r) { let s; if ("string" != typeof n) { s = h.validateNum(n), t = s; for (const n of Object.keys(e)) e[n].src.volume = e[n].volume * t } else { if (n = i(n), !e[n]) return o(`Cannot set volume of "${n}": Sound file does not exist.`); s = h.validateNum(r), e[n].volume = s, e[n].src.volume = e[n].volume * t } }, getLoop: function (t) { return t = i(t), e[t] ? e[t].src.loop : o(`Cannot get loop for "${t}": Sound file does not exist.`) }, setLoop: function (t, n) { return t = i(t), e[t] ? e[t].src.loop = n : o(`Cannot set loop for "${t}": Sound file does not exist.`) }, getTime: function (t) { return t = i(t), e[t] ? e[t].src.currentTime : o(`Cannot get time for "${t}": Sound file does not exist.`) }, setTime: function (t, n) { return t = i(t), e[t] ? e[t].src.currentTime = n : o(`Cannot set time for "${t}": Sound file does not exist.`) }, getPaused: a }); return l }(), Te = function () { const e = "localstorage", t = "indexeddb", n = {}, i = !window.indexedDB || r.autosave ? e : t, o = e => $.flatted.stringify(e), s = e => $.flatted.parse(e), c = {}, a = function (e, t, n, i, o) { c[e] || (c[e] = { data: t, flush: n, clear: i, getSize: o }) }, l = {}, d = function (e) { l[e] = e }, h = async function () { for (const e of Object.keys(c)) await c[e].flush() }; return i === e && window.addEventListener("beforeunload", h), i === t && window.addEventListener("beforeunload", function (e) { 0 !== p.objectLength(l) && (e.preventDefault(), e.returnValue = "") }), n[e] = { getLocal: function (e) { return new Promise(async (t, n) => { if (!_.isString(e)) return t(null); const i = `flevar_ls_${e}`; let r, l, d, f = {}; if (c[i]) f = c[i].data, r = c[i].flush, l = c[i].clear, d = c[i].getSize; else { const e = localStorage.getItem(i); e && (f = s(e)), r = function () { return new Promise(async (e, t) => { try { p.objectLength(f) > 0 ? localStorage.setItem(i, o(f)) : await l(), e(!0) } catch{ e(!1) } }) }, l = function () { return new Promise(async (e, t) => { try { p.emptyObject(f), localStorage.removeItem(i), e(!0) } catch{ e(!1) } }) }, d = function () { return new Blob([o(f)]).size } } a(i, f, r, l, d); const h = new u.SharedObject; Object.defineProperties(h, { data: { get: function () { return f }, enumerable: !0, configurable: !1 }, flush: { get: function () { return r }, enumerable: !1, configurable: !1 }, clear: { get: function () { return l }, enumerable: !1, configurable: !1 }, getSize: { get: function () { return d }, enumerable: !1, configurable: !1 } }), t(h) }) } }, n[t] = function () { const e = { DB_NAME: "flevar_idb", DB_STORE_NAME: "idbStorage", READ_ONLY: "readonly", READ_WRITE: "readwrite", DATABASE: void 0, _openDB: async function () { return new Promise((t, n) => { if (e.DATABASE) return t(); let i = indexedDB.open(e.DB_NAME); i.onupgradeneeded = (n => { e.DATABASE = n.target.result, e.DATABASE.onerror = function (e) { console.error("Database error: " + e.target.errorCode) }, e.DATABASE.createObjectStore(e.DB_STORE_NAME).transaction.oncomplete = function () { t() } }), i.onsuccess = function (n) { e.DATABASE = n.target.result, e.DATABASE.onerror = function (e) { console.error("Database error: " + e.target.errorCode) }, t() }, i.onerror = function (e) { console.error("Why didn't you allow my web app to use IndexedDB?!"), n("Why didn't you allow my web app to use IndexedDB?!") } }) }, _closeDB: function () { e.DATABASE && (e.DATABASE.close(), e.DATABASE = void 0) }, _handleItemQuery: function (t, n, ...i) { delete l[t], e._closeDB(), n(...i) }, _createTransaction: function (t) { return new Promise(async (n, i) => { await e._openDB(), n(e.DATABASE.transaction(e.DB_STORE_NAME, t)) }) }, getItem: function (t) { return new Promise(async (n, i) => { const o = f("idbqueue"); d(o); try { const r = (await e._createTransaction(e.READ_ONLY)).objectStore(e.DB_STORE_NAME).get(t); r.onsuccess = (() => { let t = r.result; void 0 === t && (t = null), e._handleItemQuery(o, n, t) }), r.onerror = (() => { e._handleItemQuery(o, i, r.error) }) } catch (t) { e._handleItemQuery(o, i, t) } }) }, setItem: function (t, n) { return new Promise(async (i, o) => { const r = f("idbqueue"); d(r); try { const s = await e._createTransaction(e.READ_WRITE), c = s.objectStore(e.DB_STORE_NAME); null === n && (n = void 0); const a = c.put(n, t); s.oncomplete = (() => { e._handleItemQuery(r, i) }), s.onabort = s.onerror = (() => { const t = a.error ? a.error : a.transaction.error; e._handleItemQuery(r, o, t) }) } catch (t) { e._handleItemQuery(r, o, t) } }) }, removeItem: function (t) { return new Promise(async (n, i) => { const o = f("idbqueue"); d(o); try { const r = await e._createTransaction(e.READ_WRITE), s = r.objectStore(e.DB_STORE_NAME).delete(t); r.oncomplete = (() => { e._handleItemQuery(o, n) }), r.onerror = (() => { e._handleItemQuery(o, i, s.error) }), r.onabort = (() => { const t = s.error ? s.error : s.transaction.error; e._handleItemQuery(o, i, t) }) } catch (t) { e._handleItemQuery(o, i, t) } }) } }; return { getLocal: function (t) { return new Promise(async (n, i) => { if (!_.isString(t)) return n(null); const r = `flevar_idb_${t}`; let l, d, f, h = {}; if (c[r]) h = c[r].data, l = c[r].flush, d = c[r].clear, f = c[r].getSize; else { const t = await e.getItem(r); t && (h = s(t)), l = function () { return new Promise(async (t, n) => { try { p.objectLength(h) > 0 ? await e.setItem(r, o(h)) : await d(), t(!0) } catch{ t(!1) } }) }, d = function () { return new Promise(async (t, n) => { try { p.emptyObject(h), await e.removeItem(r), t(!0) } catch{ t(!1) } }) }, f = function () { return new Blob([o(h)]).size } } a(r, h, l, d, f); const g = new u.SharedObject; Object.defineProperties(g, { data: { get: function () { return h }, enumerable: !0, configurable: !1 }, flush: { get: function () { return l }, enumerable: !1, configurable: !1 }, clear: { get: function () { return d }, enumerable: !1, configurable: !1 }, getSize: { get: function () { return f }, enumerable: !1, configurable: !1 } }), n(g) }) } } }(), new u.SharedObject({ ...n[i], flush: h, driver: i }) }(), Me = { get _width() { return r.stage._width }, get _height() { return r.stage._height }, get _scene() { return B.scene }, get _xmouse() { return C._x }, get _ymouse() { return C._y }, get _color() { return r.stage._color }, set _color(e) { return r.stage._color = e } }, Ee = new Proxy(this, { get: function (e, t) { return ee(t) } }), je = function (e) { return new u.Sound({ idName: e }) }, Ne = function (e, t, n) { return X.addLoop(e, t, n) }, He = function (e) { X.removeLoop(e) }, De = function (e, t) { return X.addTimeout(e, t) }, Be = (() => { let e = null, t = null, n = "false"; const i = [], o = { createSprite: function () { i.push({ type: "async", args: [...arguments], method: $e.createSprite }) }, createSpriteSheet: function () { i.push({ type: "async", args: [...arguments], method: $e.createSpriteSheet }) }, createGraphic: function () { i.push({ type: "async", args: [...arguments], method: $e.createGraphic }) }, createSound: function () { i.push({ type: "async", args: [...arguments], method: $e.createSound }) }, createPrefab: function () { i.push({ type: "sync", args: [...arguments], method: $e.createPrefab }) }, createTextField: function () { i.push({ type: "sync", args: [...arguments], method: $e.createTextField }) }, createScript: function () { i.push({ type: "sync", args: [...arguments], method: $e.createScript }) }, createScene: function () { i.push({ type: "sync", args: [...arguments], method: $e.createScene }) }, createPainting: function () { i.push({ type: "sync", args: [...arguments], method: $e.createPainting }) } }, s = (e, t) => { const n = Math.floor(e / t * 100) / 100; c.drawLoadBar(H.ctx, n) }, c = () => new Promise(async (r, a) => { try { await c.drawLoadStart(H.ctx), t = await e(o), await (async () => { const e = i.filter(({ type: e }) => "async" === e).length; let t = 0; s(t, e); for (const n of Object.keys(i)) { const { method: o, args: r, type: c } = i[n]; try { "async" === c ? await o(...r) : o(...r) } catch (e) { console.error(e) } "async" === c && t++, s(t, e) } })(), await c.drawLoadEnd(H.ctx), i.length = 0 } catch (e) { return console.warn(e), r() } const l = () => { H.div.removeEventListener("mousedown", l, !0), H.div.removeEventListener("keydown", l, !0), r() }; H.div.addEventListener("mousedown", l, !0), H.div.addEventListener("keydown", l, !0), n = "loaded" }); c.svgs = { logoold: '<svg width="331" height="331" viewBox="0 0 331 331" fill="none" xmlns="http://www.w3.org/2000/svg">\n    <rect x="0.0936127" y="63.259" width="275" height="275" rx="27" transform="rotate(-13.279 0.0936127 63.259)" fill="#E44D26"/>\n    <path d="M90.6 255V93H153.2V109.2H113.2V163.2H144.2V179.2H113.2V255H90.6ZM168.725 255V93H208.925C218.658 93 226.392 94.8 232.125 98.4C237.992 101.867 242.258 106.933 244.925 113.6C247.592 120.267 248.925 128.333 248.925 137.8C248.925 146.333 247.392 153.733 244.325 160C241.392 166.267 236.992 171.133 231.125 174.6C225.258 177.933 217.925 179.6 209.125 179.6H191.325V255H168.725ZM191.325 163.4H201.725C208.258 163.4 213.392 162.667 217.125 161.2C220.858 159.733 223.525 157.2 225.125 153.6C226.725 149.867 227.525 144.667 227.525 138C227.525 130.267 226.925 124.333 225.725 120.2C224.658 116.067 222.325 113.2 218.725 111.6C215.125 110 209.525 109.2 201.925 109.2H191.325V163.4Z" fill="#FBC5B7"/>\n    </svg>', logo: '<svg xmlns="http://www.w3.org/2000/svg" width="309" height="309" viewBox="0 0 309 309" fill="none">\n            <path d="M76.3824 5.61113C65.7358 2.66881 54.7198 8.91437 51.7775 19.561L50.6676 23.5769L165.207 30.1588L76.3824 5.61113Z" fill="#AB3A1C"/>\n            <path d="M6.04183 232.477C3.09951 243.123 9.34507 254.139 19.9917 257.081L24.0076 258.191L30.5808 143.684L6.04183 232.477Z" fill="#AB3A1C"/>\n            <path d="M257.512 288.867C254.57 299.514 243.554 305.759 232.907 302.817L144.083 278.269L258.622 284.851L257.512 288.867Z" fill="#AB3A1C"/>\n            <path d="M303.248 75.9517C306.19 65.3051 299.945 54.2891 289.298 51.3468L285.282 50.2369L278.7 164.776L303.248 75.9517Z" fill="#AB3A1C"/>\n            <rect x="17.4487" y="41.565" width="251.048" height="251.048" rx="20" transform="rotate(-5.61125 17.4487 41.565)" fill="#F2F2F2"/>\n            <rect x="3.6449" y="60.878" width="251.048" height="251.048" rx="20" transform="rotate(-13.279 3.6449 60.878)" fill="#E44D26"/>\n            <path d="M117.59 213.06L101.127 216.856L82.4083 135.657C81.9099 133.495 81.8422 131.256 82.2091 129.068C82.576 126.879 83.3702 124.785 84.5466 122.904C85.7229 121.023 87.2582 119.392 89.0648 118.104C90.8715 116.816 92.9141 115.897 95.0761 115.398L192.738 92.8839C194.9 92.3855 197.139 92.3178 199.327 92.6847C201.515 93.0516 203.61 93.8459 205.491 95.0222C207.372 96.1985 209.003 97.7338 210.291 99.5404C211.579 101.347 212.498 103.39 212.996 105.552L216.792 122.015C217.29 124.177 217.358 126.416 216.991 128.604C216.624 130.792 215.83 132.886 214.653 134.767C213.477 136.649 211.942 138.28 210.135 139.567L240.791 184.659L223.132 188.729L193.28 144.773L171.198 149.864L182.326 198.137L165.863 201.932L154.735 153.659L150.94 137.196L192.097 127.708C193.178 127.458 194.199 126.999 195.103 126.355C196.006 125.711 196.774 124.895 197.362 123.955C197.95 123.014 198.347 121.967 198.531 120.873C198.714 119.779 198.68 118.659 198.431 117.578C198.182 116.497 197.722 115.476 197.078 114.573C196.434 113.67 195.619 112.902 194.678 112.314C193.738 111.726 192.69 111.328 191.596 111.145C190.503 110.962 189.385 110.995 188.304 111.244L188.302 111.245L98.8713 131.861L102.667 148.324L135.593 140.734L139.388 157.197L106.462 164.787L117.59 213.06Z" fill="#F2F2F2"/>\n            </svg>', loaded: '<svg width="322" height="34" viewBox="0 0 322 34" fill="none" xmlns="http://www.w3.org/2000/svg">\n        <path d="M0.706975 8.02631H5.17137V9.47068C6.37501 8.31081 7.66618 7.73088 9.04489 7.73088C10.5768 7.73088 11.6601 8.36552 12.2947 9.63481C12.9294 10.9041 13.2467 12.3813 13.2467 14.0664V20.5004C13.2467 22.5356 12.8856 24.1769 12.1634 25.4243C11.4631 26.6717 10.347 27.2954 8.81511 27.2954C7.58959 27.2954 6.37501 26.7264 5.17137 25.5885V33.237H0.706975V8.02631ZM7.14096 24.1769C7.7756 24.1769 8.20235 23.8705 8.42119 23.2578C8.66192 22.645 8.78228 21.7806 8.78228 20.6645V13.8366C8.78228 12.8518 8.66192 12.0859 8.42119 11.5387C8.18046 10.9916 7.74278 10.7181 7.10813 10.7181C6.4516 10.7181 5.80602 10.9916 5.17137 11.5387V23.5204C5.78413 23.9581 6.44066 24.1769 7.14096 24.1769ZM16.4173 8.02631H20.8816V10.9479C21.5163 9.83177 22.1619 9.03299 22.8184 8.55154C23.4749 8.0482 24.2081 7.79653 25.0178 7.79653C25.3023 7.79653 25.5321 7.81841 25.7071 7.86218V12.4907C25.0068 12.2281 24.3941 12.0968 23.8689 12.0968C22.6871 12.0968 21.6914 12.7096 20.8816 13.9351V27H16.4173V8.02631ZM33.636 27.2954C31.5351 27.2954 29.9923 26.7155 29.0075 25.5556C28.0227 24.3739 27.5303 22.6341 27.5303 20.3362V14.6901C27.5303 12.3703 28.0227 10.6305 29.0075 9.47068C30.0142 8.31081 31.557 7.73088 33.636 7.73088C35.7807 7.73088 37.2907 8.33269 38.1661 9.53633C39.0633 10.74 39.5119 12.5564 39.5119 14.9855V17.7101H31.9619V21.4523C31.9619 22.3715 32.0932 23.0389 32.3558 23.4547C32.6403 23.8705 33.078 24.0784 33.6688 24.0784C34.2378 24.0784 34.6427 23.8815 34.8834 23.4876C35.146 23.0718 35.2773 22.4481 35.2773 21.6165V20.008H39.4791V21.321C39.4791 23.2687 38.9867 24.7569 38.0019 25.7854C37.0171 26.7921 35.5618 27.2954 33.636 27.2954ZM35.2773 15.5107V13.7053C35.2773 12.7205 35.157 12.0202 34.9162 11.6044C34.6755 11.1667 34.2488 10.9479 33.636 10.9479C33.0014 10.9479 32.5637 11.1777 32.3229 11.6372C32.0822 12.0968 31.9619 12.9503 31.9619 14.1977V15.5107H35.2773ZM47.6952 27.2954C46.0977 27.2954 44.7846 26.8687 43.756 26.0152C42.7275 25.1617 41.9944 23.9143 41.5567 22.273L44.8721 20.9928C45.3755 23.1155 46.2946 24.1769 47.6296 24.1769C48.1329 24.1769 48.5159 24.0456 48.7785 23.783C49.063 23.5204 49.2052 23.1593 49.2052 22.6997C49.2052 22.1964 49.052 21.7368 48.7457 21.321C48.4393 20.8833 47.8922 20.3362 47.1043 19.6797L44.8393 17.7101C43.8764 16.9223 43.1652 16.1563 42.7056 15.4123C42.246 14.6682 42.0162 13.76 42.0162 12.6877C42.0162 11.1995 42.5196 10.0068 43.5263 9.10959C44.5548 8.19045 45.846 7.73088 47.3998 7.73088C48.8879 7.73088 50.1025 8.1795 51.0435 9.07676C51.9845 9.95213 52.5973 11.1448 52.8818 12.6548L49.9602 13.9022C49.7852 13.0269 49.4897 12.3156 49.0739 11.7685C48.68 11.1995 48.1657 10.915 47.5311 10.915C47.0715 10.915 46.6995 11.0573 46.415 11.3418C46.1524 11.6263 46.0211 11.9874 46.0211 12.4251C46.0211 12.7752 46.1743 13.1472 46.4806 13.5412C46.787 13.9351 47.2466 14.3946 47.8593 14.9199L50.1572 17.0208C51.142 17.8742 51.897 18.6949 52.4222 19.4827C52.9693 20.2487 53.2429 21.1788 53.2429 22.273C53.2429 23.8705 52.7177 25.107 51.6672 25.9824C50.6387 26.8578 49.3147 27.2954 47.6952 27.2954ZM60.8386 27.2954C59.2411 27.2954 57.928 26.8687 56.8994 26.0152C55.8709 25.1617 55.1378 23.9143 54.7001 22.273L58.0155 20.9928C58.5189 23.1155 59.438 24.1769 60.773 24.1769C61.2763 24.1769 61.6593 24.0456 61.9219 23.783C62.2064 23.5204 62.3486 23.1593 62.3486 22.6997C62.3486 22.1964 62.1954 21.7368 61.8891 21.321C61.5827 20.8833 61.0356 20.3362 60.2477 19.6797L57.9827 17.7101C57.0198 16.9223 56.3086 16.1563 55.849 15.4123C55.3894 14.6682 55.1596 13.76 55.1596 12.6877C55.1596 11.1995 55.663 10.0068 56.6697 9.10959C57.6982 8.19045 58.9894 7.73088 60.5432 7.73088C62.0313 7.73088 63.2459 8.1795 64.1869 9.07676C65.1279 9.95213 65.7407 11.1448 66.0252 12.6548L63.1036 13.9022C62.9286 13.0269 62.6331 12.3156 62.2173 11.7685C61.8234 11.1995 61.3091 10.915 60.6745 10.915C60.2149 10.915 59.8429 11.0573 59.5584 11.3418C59.2958 11.6263 59.1645 11.9874 59.1645 12.4251C59.1645 12.7752 59.3177 13.1472 59.624 13.5412C59.9304 13.9351 60.39 14.3946 61.0027 14.9199L63.3006 17.0208C64.2854 17.8742 65.0404 18.6949 65.5656 19.4827C66.1127 20.2487 66.3863 21.1788 66.3863 22.273C66.3863 23.8705 65.8611 25.107 64.8106 25.9824C63.7821 26.8578 62.4581 27.2954 60.8386 27.2954ZM80.487 27.2954C79.6773 27.2954 78.9551 27.0766 78.3205 26.6389C77.7077 26.2012 77.2263 25.6432 76.8761 24.9648C76.5479 24.2645 76.3837 23.5423 76.3837 22.7982C76.3837 21.332 76.7229 20.1283 77.4014 19.1873C78.1016 18.2244 78.9551 17.4803 79.9618 16.9551C80.9904 16.4299 82.3472 15.8499 84.0323 15.2153V13.574C84.0323 12.6986 83.9229 12.064 83.704 11.67C83.5071 11.2542 83.1132 11.0463 82.5223 11.0463C81.5156 11.0463 80.9904 11.7466 80.9466 13.1472L80.881 14.2962L76.6463 14.132C76.712 11.9436 77.2482 10.3351 78.2548 9.30654C79.2834 8.2561 80.8262 7.73088 82.8834 7.73088C84.7435 7.73088 86.1222 8.24516 87.0195 9.27372C87.9168 10.2804 88.3654 11.7138 88.3654 13.574V22.3386C88.3654 23.6955 88.4748 25.2493 88.6937 27H84.6888C84.47 25.8182 84.3168 24.91 84.2293 24.2754C83.9666 25.1289 83.518 25.8511 82.8834 26.442C82.2706 27.0109 81.4718 27.2954 80.487 27.2954ZM82.1284 23.98C82.5004 23.98 82.8505 23.8487 83.1788 23.586C83.529 23.3234 83.8135 23.0389 84.0323 22.7326V17.4147C82.8724 18.0931 82.008 18.7496 81.439 19.3843C80.87 19.997 80.5855 20.7739 80.5855 21.7149C80.5855 22.4152 80.7168 22.9733 80.9794 23.3891C81.2639 23.783 81.6469 23.98 82.1284 23.98ZM91.6529 8.02631H96.1173V9.89742C97.6273 8.45306 99.1592 7.73088 100.713 7.73088C101.785 7.73088 102.584 8.12479 103.109 8.91263C103.656 9.70046 103.93 10.6962 103.93 11.8998V27H99.4656V12.7861C99.4656 12.1734 99.3671 11.7248 99.1702 11.4403C98.9951 11.1558 98.6668 11.0135 98.1854 11.0135C97.6601 11.0135 96.9708 11.3199 96.1173 11.9327V27H91.6529V8.02631ZM107.332 28.9368C108.514 28.9368 109.345 28.8273 109.827 28.6085C110.33 28.4115 110.582 28.0176 110.582 27.4267C110.582 27.0328 110.352 25.9167 109.892 24.0784L105.723 8.02631H110.056L112.518 20.566L114.652 8.02631H118.952L114.521 27.755C114.149 29.3526 113.438 30.4796 112.387 31.1361C111.359 31.8145 109.958 32.1538 108.185 32.1538H107.332V28.9368ZM129.065 0.37775H133.497V15.6749L138.355 8.02631H143.246L138.486 15.642L143.148 27H138.453L135.007 17.6445L133.497 19.7454V26.9672H129.065V0.37775ZM150.676 27.2954C148.576 27.2954 147.033 26.7155 146.048 25.5556C145.063 24.3739 144.571 22.6341 144.571 20.3362V14.6901C144.571 12.3703 145.063 10.6305 146.048 9.47068C147.055 8.31081 148.597 7.73088 150.676 7.73088C152.821 7.73088 154.331 8.33269 155.206 9.53633C156.104 10.74 156.552 12.5564 156.552 14.9855V17.7101H149.002V21.4523C149.002 22.3715 149.134 23.0389 149.396 23.4547C149.681 23.8705 150.118 24.0784 150.709 24.0784C151.278 24.0784 151.683 23.8815 151.924 23.4876C152.186 23.0718 152.318 22.4481 152.318 21.6165V20.008H156.52V21.321C156.52 23.2687 156.027 24.7569 155.042 25.7854C154.058 26.7921 152.602 27.2954 150.676 27.2954ZM152.318 15.5107V13.7053C152.318 12.7205 152.197 12.0202 151.957 11.6044C151.716 11.1667 151.289 10.9479 150.676 10.9479C150.042 10.9479 149.604 11.1777 149.363 11.6372C149.123 12.0968 149.002 12.9503 149.002 14.1977V15.5107H152.318ZM159.713 28.9368C160.895 28.9368 161.727 28.8273 162.208 28.6085C162.711 28.4115 162.963 28.0176 162.963 27.4267C162.963 27.0328 162.733 25.9167 162.274 24.0784L158.105 8.02631H162.438L164.9 20.566L167.033 8.02631H171.334L166.902 27.755C166.53 29.3526 165.819 30.4796 164.768 31.1361C163.74 31.8145 162.339 32.1538 160.567 32.1538H159.713V28.9368ZM186.863 27.2298C185.134 27.2298 183.908 26.814 183.186 25.9824C182.486 25.1508 182.136 23.9143 182.136 22.273V10.9479H180.232V8.02631H182.136V2.34734H186.633V8.02631H189.489V10.9479H186.633V21.8791C186.633 22.5137 186.764 22.9733 187.027 23.2578C187.311 23.5423 187.749 23.6845 188.34 23.6845C188.887 23.6845 189.347 23.6408 189.719 23.5532V27C188.843 27.1532 187.891 27.2298 186.863 27.2298ZM198.025 27.2954C195.989 27.2954 194.468 26.7374 193.462 25.6213C192.455 24.4833 191.952 22.842 191.952 20.6973V14.329C191.952 12.1843 192.455 10.5539 193.462 9.43785C194.468 8.29987 195.989 7.73088 198.025 7.73088C200.06 7.73088 201.581 8.29987 202.588 9.43785C203.616 10.5539 204.13 12.1843 204.13 14.329V20.6973C204.13 22.842 203.616 24.4833 202.588 25.6213C201.581 26.7374 200.06 27.2954 198.025 27.2954ZM198.058 24.2098C198.736 24.2098 199.185 23.9471 199.403 23.4219C199.622 22.8748 199.732 22.076 199.732 21.0256V14.0336C199.732 12.9831 199.622 12.1843 199.403 11.6372C199.185 11.0901 198.736 10.8166 198.058 10.8166C197.357 10.8166 196.898 11.0901 196.679 11.6372C196.46 12.1843 196.351 12.9831 196.351 14.0336V21.0256C196.351 22.076 196.46 22.8748 196.679 23.4219C196.898 23.9471 197.357 24.2098 198.058 24.2098ZM220.913 27.2954C218.79 27.2954 217.247 26.7046 216.284 25.5228C215.321 24.3192 214.84 22.6013 214.84 20.3691V14.6573C214.84 12.4032 215.321 10.6853 216.284 9.5035C217.247 8.32175 218.79 7.73088 220.913 7.73088C222.926 7.73088 224.392 8.21233 225.311 9.17524C226.252 10.1381 226.723 11.6044 226.723 13.574V15.1497H222.521V13.4755C222.521 12.4907 222.401 11.8123 222.16 11.4403C221.941 11.0682 221.536 10.8822 220.946 10.8822C220.311 10.8822 219.873 11.112 219.632 11.5716C219.414 12.0311 219.304 12.8737 219.304 14.0992V21.0584C219.304 22.2402 219.425 23.0499 219.665 23.4876C219.928 23.9253 220.355 24.1441 220.946 24.1441C221.558 24.1441 221.974 23.9471 222.193 23.5532C222.412 23.1374 222.521 22.4809 222.521 21.5836V19.5484H226.723V21.3539C226.723 23.3016 226.252 24.7787 225.311 25.7854C224.37 26.7921 222.904 27.2954 220.913 27.2954ZM235.435 27.2954C233.4 27.2954 231.879 26.7374 230.872 25.6213C229.866 24.4833 229.362 22.842 229.362 20.6973V14.329C229.362 12.1843 229.866 10.5539 230.872 9.43785C231.879 8.29987 233.4 7.73088 235.435 7.73088C237.471 7.73088 238.992 8.29987 239.998 9.43785C241.027 10.5539 241.541 12.1843 241.541 14.329V20.6973C241.541 22.842 241.027 24.4833 239.998 25.6213C238.992 26.7374 237.471 27.2954 235.435 27.2954ZM235.468 24.2098C236.147 24.2098 236.595 23.9471 236.814 23.4219C237.033 22.8748 237.142 22.076 237.142 21.0256V14.0336C237.142 12.9831 237.033 12.1843 236.814 11.6372C236.595 11.0901 236.147 10.8166 235.468 10.8166C234.768 10.8166 234.308 11.0901 234.089 11.6372C233.871 12.1843 233.761 12.9831 233.761 14.0336V21.0256C233.761 22.076 233.871 22.8748 234.089 23.4219C234.308 23.9471 234.768 24.2098 235.468 24.2098ZM244.629 8.02631H249.094V9.89742C250.604 8.45306 252.136 7.73088 253.689 7.73088C254.762 7.73088 255.56 8.12479 256.086 8.91263C256.633 9.70046 256.906 10.6962 256.906 11.8998V27H252.442V12.7861C252.442 12.1734 252.343 11.7248 252.147 11.4403C251.971 11.1558 251.643 11.0135 251.162 11.0135C250.637 11.0135 249.947 11.3199 249.094 11.9327V27H244.629V8.02631ZM265.659 27.2298C263.93 27.2298 262.705 26.814 261.982 25.9824C261.282 25.1508 260.932 23.9143 260.932 22.273V10.9479H259.028V8.02631H260.932V2.34734H265.429V8.02631H268.285V10.9479H265.429V21.8791C265.429 22.5137 265.56 22.9733 265.823 23.2578C266.108 23.5423 266.545 23.6845 267.136 23.6845C267.683 23.6845 268.143 23.6408 268.515 23.5532V27C267.639 27.1532 266.688 27.2298 265.659 27.2298ZM271.208 1.29689H275.672V5.00628H271.208V1.29689ZM271.208 8.02631H275.672V27H271.208V8.02631ZM279.219 8.02631H283.683V9.89742C285.193 8.45306 286.725 7.73088 288.279 7.73088C289.351 7.73088 290.15 8.12479 290.675 8.91263C291.222 9.70046 291.496 10.6962 291.496 11.8998V27H287.032V12.7861C287.032 12.1734 286.933 11.7248 286.736 11.4403C286.561 11.1558 286.233 11.0135 285.751 11.0135C285.226 11.0135 284.537 11.3199 283.683 11.9327V27H279.219V8.02631ZM297.819 27.2954C296.747 27.2954 295.948 26.9015 295.423 26.1137C294.898 25.3259 294.635 24.3301 294.635 23.1265V8.02631H299.067V22.3058C299.067 22.8967 299.165 23.3453 299.362 23.6517C299.559 23.9581 299.898 24.1113 300.38 24.1113C300.883 24.1113 301.551 23.8158 302.382 23.225V8.02631H306.847V27H302.382V25.1945C300.916 26.5951 299.395 27.2954 297.819 27.2954ZM316.027 27.2954C313.926 27.2954 312.383 26.7155 311.398 25.5556C310.413 24.3739 309.921 22.6341 309.921 20.3362V14.6901C309.921 12.3703 310.413 10.6305 311.398 9.47068C312.405 8.31081 313.948 7.73088 316.027 7.73088C318.171 7.73088 319.681 8.33269 320.557 9.53633C321.454 10.74 321.903 12.5564 321.903 14.9855V17.7101H314.353V21.4523C314.353 22.3715 314.484 23.0389 314.747 23.4547C315.031 23.8705 315.469 24.0784 316.06 24.0784C316.629 24.0784 317.033 23.8815 317.274 23.4876C317.537 23.0718 317.668 22.4481 317.668 21.6165V20.008H321.87V21.321C321.87 23.2687 321.378 24.7569 320.393 25.7854C319.408 26.7921 317.953 27.2954 316.027 27.2954ZM317.668 15.5107V13.7053C317.668 12.7205 317.548 12.0202 317.307 11.6044C317.066 11.1667 316.64 10.9479 316.027 10.9479C315.392 10.9479 314.954 11.1777 314.714 11.6372C314.473 12.0968 314.353 12.9503 314.353 14.1977V15.5107H317.668Z" fill="#2E323F"/>\n        </svg>' }, c.dimensions = function () { const e = r.stage._width, t = r.stage._height, n = Math.min(e, t), i = Math.min(.4 * n, 400), o = i / 5, s = t / 10, c = i / 10, a = i + c + o, l = e / 2 - i / 2, u = t / 2 - s + a / 2 - c; return { logoX: e / 2 - i / 2, logoY: t / 2 - s - a / 2, logoSize: i, loadBarWidth: i, loadBarHeight: c, loadBarX: l, loadBarY: u, loadingBarWidth: i - 4, loadingBarHeight: c - 4, loadingBarX: l + 2, loadingBarY: u + 2, loadedTextY: u + c + o / 2 } }(), c.drawLoadBar = function (e, t) { const { loadBarWidth: n, loadBarHeight: i, loadBarX: o, loadBarY: r, loadingBarWidth: s, loadingBarHeight: c, loadingBarX: a, loadingBarY: l } = this.dimensions; e.fillStyle = "#6F737F", e.fillRect(o, r, n, i), e.fillStyle = "#2E323F", e.fillRect(a, l, s * t, c) }, c.drawLoadStart = async function (e) { const { width: t, height: n } = e; e.fillStyle = "#3B4050", e.fillRect(0, 0, t, n), await this.drawLogo(e) }, c.drawLoadEnd = async function (e) { await this.drawLoaded(e) }, c.drawLogo = function (e) { const { logoX: t, logoY: n, logoSize: i } = this.dimensions, o = this.svgs.logo; return new Promise((s, c) => { const a = new r.Image; a.onload = (() => { e.drawImage(a, t, n, i, i), s() }), a.onerror = (() => { e.fillStyle = "#E44D26", e.fillRect(t, n, i, i), s() }), a.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(o)}` }) }, c.drawLoaded = function (e) { const { loadBarWidth: t, loadBarHeight: n, loadedTextY: i, loadBarX: o } = this.dimensions, s = this.svgs.loaded; return new Promise((c, a) => { const l = new r.Image; l.onload = (() => { e.drawImage(l, o, i, t, n), c() }), l.onerror = (() => { e.save(), e.fillStyle = "#2E323F", e.font = `bold ${n}px sans-serif`, e.textBaseline = "top", e.fillText("press any key to continue", o, i, t), e.restore(), c() }), l.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(s)}` }) }; const a = function (e) { xe(r.fps) }; return { performload: function (i) { ve(), _.isScriptOrFunction(i) && (e = G($.getScriptOrFunction(i)).bind(o)), (async () => { n = "loading", _.isScriptOrFunction(e) && await c(), n = "ready", _.isScriptOrFunction(t) && await $.getScriptOrFunction(t)(), a() })() }, endload: a, get state() { return n } } })(), Ie = new u.Engine({ meta: Le, Mouse: ke, Key: Ae, Sound: Fe, SharedObject: Te, stage: Me, utils: _, _root: Ee, state: g, changeState: (e, t) => { const n = {}; n[e] = t, te(n), N() }, useState: e => { if (_.isObject(e)) { const t = e; ne(), te(t), N() } else if (_.isScriptOrFunction(e)) { const t = p.deepCloneObject(g), n = $.getScriptOrFunction(e)(t); ne(), te(n), N() } }, setState: e => { if (_.isObject(e)) te(e), N(); else if (_.isScriptOrFunction(e)) { const t = p.deepCloneObject(g), n = $.getScriptOrFunction(e)(t); te(n), N() } }, addScript: function (e) { if (_.isString(e)) { const t = ae(e); B.scripts.push(G(t).bind(Ve)) } else if (_.isScriptOrFunction(e)) { const t = $.getScriptOrFunction(e); B.scripts.push(G(t).bind(Ve)) } }, useScene: async function (e) { R.checkSceneNotExist(e), B.scene !== e && ("" !== B.scene && (await D.scenes[B.scene].__private__.__unload(), ge()), B.scene = e, await D.scenes[B.scene].__private__.__load()) }, resetScene: async function () { "" !== B.scene && (await D.scenes[B.scene].__private__.__unload(), ge(), await D.scenes[B.scene].__private__.__load()) }, attachPrefab: async (...e) => { await se("prefab", ...e) }, attachTextField: async (...e) => { await se("textfield", ...e) }, removePrefab: function (e) { ce("prefab", e) }, removeTextField: function (e) { ce("textfield", e) }, createPrefab: function (e, t, n) { ie("prefab", e, t, n) }, createTextField: function (e, t, n) { ie("textfield", e, t, n) }, createScene: function (e, t) { R.checkSceneExist(e), D.scenes[e] = function (e) { const t = {}; let n = null, i = !1; const o = () => { _.isScriptOrFunction(n) && $.getScriptOrFunction(n)(v) }, r = { scripts: [], flevaclips: {}, visuals: { name: null, src: null, type: null } }, s = [], c = []; if (_.isScriptOrFunction(e)) s.push($.getScriptOrFunction(e)); else if (_.isArray(e)) for (const t of Object.keys(e)) { const n = e[t]; _.isScriptOrFunction(n) && s.push($.getScriptOrFunction(n)) } let a = 0; const l = e => { for (const n of Object.keys(e)) t[n] = e[n] }, d = () => { for (const e of Object.keys(t)) delete t[e] }, h = { list: [], addToMainStack: () => { for (const e of Object.keys(h.list)) y.list.push(h.list[e]); y.sortList() }, removeFromMainStack: () => { for (const e of Object.keys(h.list)) { const t = h.list[e], n = y.list.findIndex(e => e.stackName === t.stackName); -1 !== n && y.list.splice(n, 1) } } }, g = (e, t, n, o, s, c) => { const a = f("stack"), l = { swapDepths: e => y.swapDepths(a, e) }, u = "prefab" === e ? z : "textfield" === e && Z; r.flevaclips[t] = { stackName: a, instanceName: n, preserve: o, instance: u(s, c, l) }, h.list[h.list.length] = { stackName: a, depth: 1, instance: r.flevaclips[t].instance, render: function () { this.instance.__private__.__render() } }, i && y.sortList() }, m = (e, ...t) => { let n, i, o, s = {}, c = !1; if (_.isString(t[0])) { const l = t[0]; _.isObject(t[1]) && _.isScriptOrFunction(t[2]) ? (s = t[1] || {}, n = $.getScriptOrFunction(t[2])) : _.isScriptOrFunction(t[1]) ? n = $.getScriptOrFunction(t[1]) : _.isObject(t[1]) && (s = t[1] || {}); const { instanceName: u, preserve: d = !1, ...f } = s; if ([i, c, o] = [u, d, f], !(r.flevaclips[a] && r.flevaclips[a].preserve && c)) { const t = J(l).__private__, r = t.___getType(); if (e !== r) throw `Expected ${e} flevaclip but received ${r} instead.`; let s = t.___getInit(); n && (s = [...s, n]); const u = t.___getProps(); g(e, a, i, c, { ...u, ...o }, s) } a++ } else if (_.isObject(t[0]) && _.isScriptOrFunction(t[1])) { s = t[0] || {}; const n = $.getScriptOrFunction(t[1]), { instanceName: l, preserve: u = !1, ...d } = s;[i, c, o] = [l, u, d], r.flevaclips[a] && r.flevaclips[a].preserve && c || g(e, a, i, c, o, n), a++ } else if (_.isScriptOrFunction(t[0])) { const n = $.getScriptOrFunction(t[0]), { instanceName: l, preserve: u = !1, ...d } = s;[i, c, o] = [l, u, d], r.flevaclips[a] && r.flevaclips[a].preserve && c || g(e, a, i, c, o, n), a++ } else if (_.isObject(t[0])) { s = t[0] || {}; const n = V, { instanceName: l, preserve: u = !1, ...d } = s;[i, c, o] = [l, u, d], r.flevaclips[a] && r.flevaclips[a].preserve && c || g(e, a, i, c, o, n), a++ } }, C = () => { r.visuals.name = null, r.visuals.src = null, r.visuals.type = null }, w = { flevaclipCount: () => a }, S = { ___getFlevaClipByInstanceName: e => { for (const t of Object.keys(r.flevaclips)) if (r.flevaclips[t].instanceName === e) return r.flevaclips[t].instance }, __start: function () { for (const e of Object.keys(r.flevaclips)) r.flevaclips[e].instance.__private__.__start() }, __stop: function () { for (const e of Object.keys(r.flevaclips)) r.flevaclips[e].instance.__private__.__stop() }, __load: async () => { if (!i) { if (s.length > 0) for (const e of Object.keys(s)) { const t = s[e].bind(x), n = await t(x); _.isScriptOrFunction(n) && c.push($.getScriptOrFunction(n)) } h.addToMainStack(); for (const e of Object.keys(r.flevaclips)) await r.flevaclips[e].instance.__private__.__load(); o(), i = !0 } }, __unload: async () => { if (i) { if (c.length > 0) { for (const e of Object.keys(c)) { const t = c[e].bind(x); await t(x) } c.length = 0 } h.removeFromMainStack(); for (const e of Object.keys(r.flevaclips)) if (!r.flevaclips[e].preserve) { const t = r.flevaclips[e], n = h.list.findIndex(e => e.stackName === t.stackName); -1 !== n && h.list.splice(n, 1), await t.instance.__private__.__unload(), delete r.flevaclips[e] } a = 0, r.scripts.length = 0, i = !1 } }, __tick: async function () { for (const e of Object.keys(r.scripts)) { const t = r.scripts[e]; await t(x) } for (const e of Object.keys(r.flevaclips)) _.isDefined(r.flevaclips[e]) && await r.flevaclips[e].instance.__private__.__tick() }, __render: function () { r.visuals.type === _.typeOf(u.Sprite) || r.visuals.type === _.typeOf(u.SpriteSheet) ? $.renderScene($.drawSprite, [r.visuals.src]) : r.visuals.type === _.typeOf(u.Graphic) ? $.renderScene($.drawGraphic, [r.visuals.src]) : r.visuals.type === _.typeOf(u.Painting) && $.renderScene($.drawPainting, [r.visuals.src]) } }, b = new u.Scene({ propertyUtils: w, state: t, changeState: (e, t) => { const n = {}; n[e] = t, l(n), o() }, useState: e => { if (_.isObject(e)) { const t = e; d(), l(t), o() } else if (_.isScriptOrFunction(e)) { const n = p.deepCloneObject(t), i = $.getScriptOrFunction(e)(n); d(), l(i), o() } }, setState: e => { if (_.isObject(e)) l(e), o(); else if (_.isScriptOrFunction(e)) { const n = p.deepCloneObject(t), i = $.getScriptOrFunction(e)(n); l(i), o() } }, addPrefab: (...e) => { m("prefab", ...e) }, addTextField: (...e) => { m("textfield", ...e) }, addScript: e => { if (_.isString(e)) { const t = ae(e); r.scripts.push(G(t).bind(x)) } else if (_.isScriptOrFunction(e)) { const t = $.getScriptOrFunction(e); r.scripts.push(G(t).bind(x)) } }, setAppearance: e => { if (_.isString(e)) { const t = ae(e); n = G(t).bind(v) } else if (_.isScriptOrFunction(e)) { const t = $.getScriptOrFunction(e); n = G(t).bind(v) } } }); Object.defineProperties(b, { __private__: { get: function () { return S }, enumerable: !1, configurable: !1 } }); const x = b, v = { state: t, useGraphic: e => { _.isGraphic(e) && (e = e.idName), R.checkGraphicNotExist(e), r.visuals.type === _.typeOf(u.Graphic) && r.visuals.name === e || (C(), r.visuals.name = e, r.visuals.src = e, r.visuals.type = _.typeOf(u.Graphic)) }, usePainting: e => { if (_.isPainting(e) && (e = e.idName), _.isString(e)) { const t = e; if (R.checkPaintingNotExist(t), r.visuals.type === _.typeOf(u.Painting) && r.visuals.name === t) return; C(), r.visuals.name = t, r.visuals.src = t, r.visuals.type = _.typeOf(u.Painting) } else if (_.isScriptOrFunction(e)) { C(); const t = $.getScriptOrFunction(e); r.visuals.name = "painting", r.visuals.src = t.bind(H.ctx), r.visuals.type = _.typeOf(u.Painting) } } }; return b }(t) }, createScript: function (e, t) { R.checkScriptExist(e), D.scripts[e] = G(t) }, createSprite: async function (e, t, n) { R.checkSpriteExist(e), D.sprites[e] = await function (e, { _width: t = 100, _height: n = 100, _canHit: i = !0 } = {}, o) { return new Promise(async (s, c) => { let a, l, d; const [f, h, p, g] = [0, 0, t, n]; if (_.isScriptOrFunction(o)) try { l = (a = document.createElement("canvas")).getContext("2d"), a.width = p, a.height = g, (o = $.getScriptOrFunction(o).bind(l))(l, f, h, p, g), d = !0 } catch{ } else if (_.isGraphic(o)) try { let e; e = o.src ? o.src : de(o.idName).src, l = (a = document.createElement("canvas")).getContext("2d"), a.width = p, a.height = g, l.imageSmoothingEnabled = !1, l.drawImage(e, f, h, p, g), d = !0 } catch{ } else if (_.isString(o)) try { let e; e = o.src ? o.src : le(o).src, l = (a = document.createElement("canvas")).getContext("2d"), a.width = p, a.height = g, l.imageSmoothingEnabled = !1, l.drawImage(e, f, h, p, g), d = !0 } catch{ } else if (_.isSprite(o)) try { let e; e = o.src ? o.src : le(o.idName).src, l = (a = document.createElement("canvas")).getContext("2d"), a.width = p, a.height = g, l.imageSmoothingEnabled = !1, l.drawImage(e, f, h, p, g), d = !0 } catch{ } else if (_.isPainting(o)) try { let e; e = o.src ? o.src : fe(o.idName).src, l = (a = document.createElement("canvas")).getContext("2d"), a.width = p, a.height = g, (e = e.bind(l))(l, f, h, p, g), d = !0 } catch{ } if (!d) { console.warn(`No sprite method found for "${e}". Using default backup.`); const t = r.sprite; l = (a = document.createElement("canvas")).getContext("2d"), a.width = p, a.height = g, l.imageSmoothingEnabled = !1, l.drawImage(t, f, h, p, g) } const m = await Q(a); let y; i && (y = { data: q(a, l), _width: a.width, _height: a.height }), s(new u.Sprite({ idName: e, src: m, pixelMap: y })) }) }(e, t, n) }, createSpriteSheet: async function (e, t, ...n) { R.checkSpriteSheetExist(e), D.spritesheets[e] = await K(e, t, ...n) }, createGraphic: async function (e, t) { R.checkGraphicExist(e), D.graphics[e] = await function (e, { _path: t = r.graphicPath, _type: n = r.graphicType, _name: i, _src: o } = {}) { return new Promise((s, c) => { const a = o || `${t}/${i || e}.${n}`, l = new r.Image; l.onload = function () { const t = new u.Graphic({ src: l, idName: e }); s(t) }, l.onerror = function () { console.warn(`Graphic load for "${e}" failed. Using default backup.`); const t = new u.Graphic({ src: r.unknowngraphic, idName: e }); s(t) }, l.src = a }) }(e, t) }, createPainting: function (e, t) { R.checkPaintingExist(e), D.paintings[e] = function (e, t) { const n = t.bind(H.ctx); return new u.Painting({ src: n, idName: e }) }(e, t) }, createSound: async function (e, t) { await Fe.create(e, t) }, getScript: function (e) { const t = new u.Script; return t.idName = e, p.lockObject(t), t }, getSprite: function (e) { return new u.Sprite({ idName: e }) }, getSpriteSheet: function (e) { return new u.SpriteSheet({ idName: e }) }, getGraphic: function (e) { return new u.Graphic({ idName: e }) }, getPainting: function (e) { return new u.Painting({ idName: e }) }, getSound: je, PXS: h.perXSeconds, XPS: h.xPerSecond, trace: $.trace, createLoop: Ne, pauseLoop: function (e) { X.pauseLoop(e) }, playLoop: function (e, t) { X.playLoop(e, t) }, deleteLoop: He, createTimeout: De, deleteTimeout: function (e) { X.removeTimeout(e) }, start: xe, stop: ve, sleep: function (e) { return new Promise((t, n) => { De(() => t(), e) }) }, useLoader: Be.performload }); Object.defineProperties(Ie, { FPS: { get: function () { return we.fps }, enumerable: !1, configurable: !1 }, SPF: { get: function () { return we.spf }, enumerable: !1, configurable: !1 } }); const Ve = Ie, $e = Ve; return async function () { document.addEventListener("visibilitychange", Oe, !1), H.div.addEventListener("contextmenu", Pe), H.div.addEventListener("mousemove", x, !1), H.div.addEventListener("mousedown", v, !0), H.div.addEventListener("mouseup", P, !1), H.div.addEventListener("mouseleave", O, !1), H.div.addEventListener("keydown", M, !0), H.div.addEventListener("keyup", E, !1), H.div.onselectstart = function () { return !1 }; const e = document.createElement("style"); e.innerHTML = "\n        *,\n        *::before,\n        *::after {\n          /*box-sizing: border-box;*/\n        }\n        "; const t = document.querySelector("script"); if (t.parentNode.insertBefore(e, t), _.isScriptOrFunction(r.inits)) i.push($.getScriptOrFunction(r.inits)); else if (_.isArray(r.inits)) for (const e of Object.keys(r.inits)) { const t = r.inits[e]; _.isScriptOrFunction(t) && i.push($.getScriptOrFunction(t)) } if (i.length > 0) for (const e of Object.keys(i)) { const t = i[e].bind(Ve), n = await t(Ve); _.isScriptOrFunction(n) && o.push($.getScriptOrFunction(n)) } Be.endload() }(), Ie }